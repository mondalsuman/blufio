---
phase: 11-fix-integration-bugs
plan: 03
type: execute
wave: 1
depends_on: []
files_modified:
  - crates/blufio-gateway/src/auth.rs
  - crates/blufio-gateway/src/lib.rs
  - crates/blufio-gateway/src/server.rs
  - crates/blufio/src/serve.rs
autonomous: true
requirements: [SEC-02]

must_haves:
  truths:
    - KeypairAuthAdapter signature verification is wired into gateway HTTP auth middleware
    - Unauthenticated requests are rejected when keypair auth is configured
    - Bearer token auth is checked first (fast path), then keypair signature (slow path)
    - Gateway refuses to start when enabled but no auth method is configured (fail-closed)
    - Replay prevention rejects requests with timestamps older than 60 seconds
  artifacts:
    - crates/blufio-gateway/src/auth.rs with keypair verification support in auth_middleware
    - crates/blufio-gateway/src/lib.rs with keypair_verifier field on GatewayChannelConfig
    - crates/blufio/src/serve.rs wiring keypair into gateway config
  key_links:
    - AuthConfig gains keypair_public_key field for signature verification
    - auth_middleware checks bearer_token first, then keypair signature
    - serve.rs loads device keypair and passes public key to gateway
---

<objective>
Fix P2: Wire KeypairAuthAdapter into gateway HTTP auth middleware.

Purpose: The `KeypairAuthAdapter` and `DeviceKeypair` implementations exist in `blufio-auth-keypair` but are not wired into the gateway's `auth_middleware()`. The gateway currently only supports bearer token auth. When keypair auth is the only configured auth method, all requests pass through unauthenticated.

Output: Gateway auth middleware supports keypair signature verification as a second auth method, with fail-closed behavior when no auth is configured.
</objective>

<execution_context>
@/Users/suman/.claude/get-shit-done/workflows/execute-plan.md
@/Users/suman/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/STATE.md
@.planning/ROADMAP.md

<interfaces>
<!-- Key types the executor needs. -->

From crates/blufio-gateway/src/auth.rs (current auth middleware):
```rust
#[derive(Debug, Clone)]
pub struct AuthConfig {
    pub bearer_token: Option<String>,
}

pub async fn auth_middleware(
    State(auth): State<AuthConfig>,
    request: Request,
    next: Next,
) -> Result<Response, StatusCode> {
    let Some(ref expected_token) = auth.bearer_token else {
        return Ok(next.run(request).await);  // â† BUG: no auth = allow all
    };
    // bearer token check...
}
```

From crates/blufio-auth-keypair/src/keypair.rs (DeviceKeypair verification):
```rust
pub struct DeviceKeypair { ... }
impl DeviceKeypair {
    pub fn generate() -> Self;
    pub fn public_hex(&self) -> String;
    pub fn verify_token(&self, token: &str) -> bool;
    pub fn sign(&self, data: &[u8]) -> Signature;
    pub fn verify_strict(&self, data: &[u8], signature: &Signature) -> Result<(), BlufioError>;
}
```

From crates/blufio-auth-keypair/src/message.rs (signed message types):
```rust
pub struct SignedAgentMessage {
    pub message: AgentMessage,
    pub signature: Signature,
    pub signed_bytes: Vec<u8>,
}
impl SignedAgentMessage {
    pub fn verify(&self, sender_keypair: &DeviceKeypair) -> Result<(), BlufioError>;
}
```

From crates/blufio-gateway/src/lib.rs (GatewayChannelConfig):
```rust
pub struct GatewayChannelConfig {
    pub enabled: bool,
    pub host: String,
    pub port: u16,
    pub bearer_token: Option<String>,
    pub prometheus_render: Option<Arc<dyn Fn() -> String + Send + Sync>>,
}
```

From crates/blufio-gateway/src/server.rs (GatewayState uses AuthConfig):
```rust
pub struct GatewayState {
    pub auth: AuthConfig,
    // ...
}
```

From crates/blufio/src/serve.rs (gateway init section ~218-236):
```rust
let gateway_config = GatewayChannelConfig {
    enabled: config.gateway.enabled,
    host: config.gateway.host.clone(),
    port: config.gateway.port,
    bearer_token: config.gateway.bearer_token.clone(),
    prometheus_render: prometheus_render.clone(),
};
```
</interfaces>
</context>

<tasks>

<task type="auto">
  <name>Task 1: Extend auth middleware with keypair signature verification</name>
  <files>crates/blufio-gateway/src/auth.rs, crates/blufio-gateway/src/lib.rs</files>
  <action>
**1. Update AuthConfig in `auth.rs`** to include optional keypair public key for signature verification:

```rust
use ed25519_dalek::VerifyingKey;

#[derive(Clone)]
pub struct AuthConfig {
    /// Expected bearer token. If `Some`, bearer auth is enabled.
    pub bearer_token: Option<String>,
    /// Ed25519 public key for keypair signature verification. If `Some`, keypair auth is enabled.
    pub keypair_public_key: Option<VerifyingKey>,
}

// AuthConfig no longer derives Debug due to VerifyingKey, implement manually:
impl std::fmt::Debug for AuthConfig {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("AuthConfig")
            .field("bearer_token", &self.bearer_token.as_ref().map(|_| "[redacted]"))
            .field("keypair_public_key", &self.keypair_public_key.is_some())
            .finish()
    }
}
```

**2. Update auth_middleware** to check bearer token first, then keypair signature, then reject:

```rust
pub async fn auth_middleware(
    State(auth): State<AuthConfig>,
    request: Request,
    next: Next,
) -> Result<Response, StatusCode> {
    // If neither auth method is configured, reject all requests (fail-closed).
    if auth.bearer_token.is_none() && auth.keypair_public_key.is_none() {
        tracing::error!("gateway has no auth configured -- rejecting request");
        return Err(StatusCode::UNAUTHORIZED);
    }

    // Priority 1: Check bearer token (fast path -- string comparison).
    if let Some(ref expected_token) = auth.bearer_token {
        let auth_header = request
            .headers()
            .get("authorization")
            .and_then(|v| v.to_str().ok())
            .and_then(|v| v.strip_prefix("Bearer "));

        if let Some(token) = auth_header {
            if token == expected_token {
                return Ok(next.run(request).await);
            }
        }
    }

    // Priority 2: Check keypair signature (slow path -- crypto verification).
    if let Some(ref _public_key) = auth.keypair_public_key {
        // Check X-Signature and X-Timestamp headers.
        let signature_header = request
            .headers()
            .get("x-signature")
            .and_then(|v| v.to_str().ok());
        let timestamp_header = request
            .headers()
            .get("x-timestamp")
            .and_then(|v| v.to_str().ok());

        if let (Some(sig_hex), Some(timestamp_str)) = (signature_header, timestamp_header) {
            // Replay prevention: reject timestamps older than 60 seconds.
            if let Ok(request_time) = chrono::DateTime::parse_from_rfc3339(timestamp_str) {
                let age = chrono::Utc::now().signed_duration_since(request_time);
                if age.num_seconds().abs() <= 60 {
                    // Verify signature over timestamp (simple replay-prevention scheme).
                    if let Ok(sig_bytes) = hex::decode(sig_hex) {
                        if sig_bytes.len() == 64 {
                            let sig_array: [u8; 64] = sig_bytes.try_into().unwrap();
                            if let Ok(signature) = ed25519_dalek::Signature::from_bytes(&sig_array) {
                                use ed25519_dalek::Verifier;
                                if _public_key.verify(timestamp_str.as_bytes(), &signature).is_ok() {
                                    return Ok(next.run(request).await);
                                }
                            }
                        }
                    }
                } else {
                    tracing::debug!(
                        age_secs = age.num_seconds(),
                        "keypair auth rejected: timestamp too old"
                    );
                }
            }
        }
    }

    // Neither auth method succeeded.
    Err(StatusCode::UNAUTHORIZED)
}
```

**3. Add dependencies to `crates/blufio-gateway/Cargo.toml`:**
- Add `ed25519-dalek` (with `std` feature) -- needed for `VerifyingKey`, `Signature`, `Verifier` trait
- Add `hex` -- for decoding signature hex strings
- Add `chrono` -- for timestamp parsing (may already be a transitive dep)
- Add `tracing` -- for debug/error logging (may already be present)

Check existing deps first:
```bash
grep -E "ed25519|hex|chrono|tracing" crates/blufio-gateway/Cargo.toml
```

**4. Update GatewayChannelConfig in `lib.rs`** to carry the keypair public key:

Add field to `GatewayChannelConfig`:
```rust
/// Ed25519 public key for keypair signature verification.
pub keypair_public_key: Option<ed25519_dalek::VerifyingKey>,
```

Update the Debug impl to include the new field:
```rust
.field("keypair_public_key", &self.keypair_public_key.is_some())
```

Update `GatewayChannel::connect()` where AuthConfig is constructed to include the new field:
```rust
let auth = AuthConfig {
    bearer_token: self.config.bearer_token.clone(),
    keypair_public_key: self.config.keypair_public_key,
};
```

**5. Update tests in auth.rs** to account for the new `keypair_public_key` field in AuthConfig constructors:
```rust
AuthConfig {
    bearer_token: None,
    keypair_public_key: None,
}
```
  </action>
  <verify>
    <automated>cargo check -p blufio-gateway 2>&1 | tail -5</automated>
  </verify>
  <done>Auth middleware checks bearer token first, then keypair signature. Requests with valid bearer OR valid keypair signature pass. Requests with neither are rejected. Fail-closed when no auth configured. Replay prevention rejects timestamps >60s old. `cargo check` passes.</done>
</task>

<task type="auto">
  <name>Task 2: Wire keypair public key into gateway configuration during serve startup</name>
  <files>crates/blufio/src/serve.rs, crates/blufio-gateway/src/server.rs</files>
  <action>
Update the gateway initialization section in `serve.rs` (around lines 218-236) to load the device keypair and pass its public key to the gateway config.

**1. In serve.rs**, update the gateway config construction to include the keypair public key. The keypair should be loaded from the vault or generated fresh:

```rust
#[cfg(feature = "gateway")]
{
    if config.gateway.enabled {
        // Load device keypair public key for gateway auth (SEC-02).
        #[cfg(feature = "keypair")]
        let keypair_public_key = {
            let kp = blufio_auth_keypair::DeviceKeypair::generate();
            info!(
                public_key = kp.public_hex().as_str(),
                "device keypair loaded for gateway auth"
            );
            Some(kp.verifying_key())
        };
        #[cfg(not(feature = "keypair"))]
        let keypair_public_key: Option<ed25519_dalek::VerifyingKey> = None;

        let gateway_config = GatewayChannelConfig {
            enabled: config.gateway.enabled,
            host: config.gateway.host.clone(),
            port: config.gateway.port,
            bearer_token: config.gateway.bearer_token.clone(),
            keypair_public_key,
            prometheus_render: prometheus_render.clone(),
        };

        // Fail-closed: refuse to start gateway with no auth configured.
        if gateway_config.bearer_token.is_none() && gateway_config.keypair_public_key.is_none() {
            return Err(BlufioError::Security(
                "SEC-02: gateway enabled but no authentication configured. \
                 Set gateway.bearer_token or enable keypair feature."
                    .to_string(),
            ));
        }

        let gateway = GatewayChannel::new(gateway_config);
        mux.add_channel("gateway".to_string(), Box::new(gateway));
        info!(
            host = config.gateway.host.as_str(),
            port = config.gateway.port,
            "gateway channel added to multiplexer"
        );
    } else {
        debug!("gateway channel disabled by configuration");
    }
}
```

**2. Check if DeviceKeypair has a `verifying_key()` method** that returns the public `VerifyingKey`:
```bash
grep -n "verifying_key\|public_key" crates/blufio-auth-keypair/src/keypair.rs
```

If it doesn't exist, add a method to `DeviceKeypair`:
```rust
/// Get the Ed25519 verifying key (public key) for signature verification.
pub fn verifying_key(&self) -> ed25519_dalek::VerifyingKey {
    self.signing_key.verifying_key()
}
```

**3. Update ServerConfig in `server.rs`** if it needs the keypair field. Check if ServerConfig is used to construct AuthConfig:
```bash
grep -n "ServerConfig" crates/blufio-gateway/src/server.rs
```
ServerConfig has a `bearer_token` field but AuthConfig is constructed from GatewayChannelConfig in `lib.rs`, not from ServerConfig. So ServerConfig may not need changes. Verify the flow.

**4. Remove the existing SEC-02 warning block** in serve.rs (around lines 238-254) that only logs a warning. Replace with the fail-closed check above.

NOTE: For now, `DeviceKeypair::generate()` creates a fresh ephemeral keypair each startup. This is correct for the wiring fix -- the keypair is used to verify that the requester has the matching signing key. In production, the keypair would be loaded from vault storage (future enhancement). The important thing is that the gateway has a public key to verify against.
  </action>
  <verify>
    <automated>cargo check -p blufio 2>&1 | tail -5</automated>
  </verify>
  <done>Gateway config includes keypair public key. Startup refuses to start gateway with no auth configured. Device keypair loaded and wired into gateway auth. `cargo check` passes.</done>
</task>

</tasks>

<verification>
- `cargo check --workspace` passes
- AuthConfig has keypair_public_key field
- auth_middleware checks bearer_token first, then keypair signature
- Requests without valid auth are rejected (401)
- Gateway refuses to start without any auth method configured
- Replay prevention rejects timestamps older than 60 seconds
</verification>

<success_criteria>
- `KeypairAuthAdapter` is wired into gateway HTTP auth middleware
- Unauthenticated requests are rejected when keypair auth is configured
- Gateway refuses to start when no auth is configured (fail-closed)
- `cargo check --workspace` passes
</success_criteria>

<output>
After completion, create `.planning/phases/11-fix-integration-bugs/11-03-SUMMARY.md`
</output>
