---
phase: 11-fix-integration-bugs
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - crates/blufio-core/src/types.rs
  - crates/blufio-anthropic/src/lib.rs
  - crates/blufio-agent/src/lib.rs
autonomous: true
requirements: [LLM-05]

must_haves:
  truths:
    - Multi-turn tool conversations produce correct ToolUse/ToolResult content blocks in API requests
    - Anthropic API does not return 400 errors on tool follow-up calls
    - Tool results are sent as structured content blocks, not JSON-serialized text
  artifacts:
    - crates/blufio-core/src/types.rs with ToolUse and ToolResult ContentBlock variants
    - crates/blufio-anthropic/src/lib.rs with updated convert_content_blocks
    - crates/blufio-agent/src/lib.rs with structured content blocks in tool loop
  key_links:
    - ContentBlock::ToolUse maps to ApiContentBlock::ToolUse in converter
    - ContentBlock::ToolResult maps to ApiContentBlock::ToolResult in converter
    - Agent tool loop emits ContentBlock::ToolUse/ToolResult instead of Text with JSON
---

<objective>
Fix P0: Tool content block serialization bug that breaks all multi-turn tool conversations.

Purpose: The agent currently wraps tool_use and tool_result content blocks in `ContentBlock::Text` with JSON-serialized payloads. The Anthropic API expects structured `tool_use` and `tool_result` content block types, not text containing JSON. This causes 400 errors on every tool follow-up call.

Output: ContentBlock enum gains ToolUse and ToolResult variants, converter handles them, and the agent tool loop emits structured blocks.
</objective>

<execution_context>
@/Users/suman/.claude/get-shit-done/workflows/execute-plan.md
@/Users/suman/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/STATE.md
@.planning/ROADMAP.md

<interfaces>
<!-- Key types the executor needs. Extracted from codebase. -->

From crates/blufio-core/src/types.rs (current ContentBlock):
```rust
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(tag = "type")]
pub enum ContentBlock {
    #[serde(rename = "text")]
    Text { text: String },
    #[serde(rename = "image")]
    Image { source_type: String, media_type: String, data: String },
}
```

From crates/blufio-anthropic/src/types.rs (API types already have ToolUse/ToolResult):
```rust
pub enum ApiContentBlock {
    #[serde(rename = "text")]
    Text { text: String },
    #[serde(rename = "image")]
    Image { source: ImageSource },
    #[serde(rename = "tool_use")]
    ToolUse { id: String, name: String, input: serde_json::Value },
    #[serde(rename = "tool_result")]
    ToolResult { tool_use_id: String, content: String, #[serde(skip_serializing_if = "Option::is_none")] is_error: Option<bool> },
}
```

From crates/blufio-core/src/types.rs (ToolUseData for tool loop):
```rust
pub struct ToolUseData {
    pub id: String,
    pub name: String,
    pub input: serde_json::Value,
}
```

From crates/blufio-skill/src/tool.rs (ToolOutput from tool execution):
```rust
pub struct ToolOutput {
    pub content: String,
    pub is_error: bool,
}
```

From crates/blufio-anthropic/src/lib.rs (converter function at line 411):
```rust
fn convert_content_blocks(blocks: &[ContentBlock]) -> ApiContent {
    // Currently only handles Text and Image variants
}
```
</interfaces>
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add ToolUse and ToolResult variants to ContentBlock enum</name>
  <files>crates/blufio-core/src/types.rs</files>
  <action>
Add two new variants to the `ContentBlock` enum (at `types.rs:126`), following the existing tagged enum pattern with `#[serde(tag = "type")]`:

```rust
/// Tool use content block (assistant requests tool execution).
#[serde(rename = "tool_use")]
ToolUse {
    id: String,
    name: String,
    input: serde_json::Value,
},
/// Tool result content block (user provides tool execution result).
#[serde(rename = "tool_result")]
ToolResult {
    tool_use_id: String,
    content: String,
    #[serde(skip_serializing_if = "Option::is_none")]
    is_error: Option<bool>,
},
```

Then update `convert_content_blocks` in `crates/blufio-anthropic/src/lib.rs` (at line 411) to handle the new variants. Add two match arms in the `.map(|block| match block { ... })` closure:

```rust
ContentBlock::ToolUse { id, name, input } => ApiContentBlock::ToolUse {
    id: id.clone(),
    name: name.clone(),
    input: input.clone(),
},
ContentBlock::ToolResult { tool_use_id, content, is_error } => ApiContentBlock::ToolResult {
    tool_use_id: tool_use_id.clone(),
    content: content.clone(),
    is_error: *is_error,
},
```

IMPORTANT: The single-block optimization at the top of `convert_content_blocks` (line 412-416) currently only matches `ContentBlock::Text`. Leave that optimization as-is -- it only applies to text-only messages. The new variants will always go through the multi-block path, which is correct since tool messages always have multiple content blocks.
  </action>
  <verify>
    <automated>cargo check -p blufio-core -p blufio-anthropic 2>&1 | tail -5</automated>
  </verify>
  <done>ContentBlock enum has ToolUse and ToolResult variants. Anthropic converter handles all 4 variant types. `cargo check` passes for both crates.</done>
</task>

<task type="auto">
  <name>Task 2: Fix agent tool loop to emit structured content blocks</name>
  <files>crates/blufio-agent/src/lib.rs</files>
  <action>
Fix the tool follow-up message construction in `lib.rs` (lines 399-415). Currently, the code wraps tool_use and tool_result data in `ContentBlock::Text` with JSON serialization. Replace with structured `ContentBlock::ToolUse` and `ContentBlock::ToolResult` variants.

**Replace lines 399-415** (the two `messages.push` calls) with:

For the assistant message (tool_use blocks), replace:
```rust
// OLD (line 400-406):
messages.push(ProviderMessage {
    role: "assistant".to_string(),
    content: vec![ContentBlock::Text {
        text: serde_json::to_string(&assistant_content_blocks).unwrap_or_default(),
    }],
});
```

With:
```rust
// Build proper ContentBlock variants from the JSON values
let mut assistant_blocks: Vec<ContentBlock> = Vec::new();
if !text.is_empty() {
    assistant_blocks.push(ContentBlock::Text { text: text.clone() });
}
for tu in &tool_uses {
    assistant_blocks.push(ContentBlock::ToolUse {
        id: tu.id.clone(),
        name: tu.name.clone(),
        input: tu.input.clone(),
    });
}
messages.push(ProviderMessage {
    role: "assistant".to_string(),
    content: assistant_blocks,
});
```

For the user message (tool_result blocks), replace:
```rust
// OLD (line 409-415):
messages.push(ProviderMessage {
    role: "user".to_string(),
    content: vec![ContentBlock::Text {
        text: serde_json::to_string(&tool_result_blocks).unwrap_or_default(),
    }],
});
```

With:
```rust
let result_blocks: Vec<ContentBlock> = tool_results
    .iter()
    .map(|(tool_use_id, output)| ContentBlock::ToolResult {
        tool_use_id: tool_use_id.clone(),
        content: output.content.clone(),
        is_error: if output.is_error { Some(true) } else { None },
    })
    .collect();
messages.push(ProviderMessage {
    role: "user".to_string(),
    content: result_blocks,
});
```

Note: The `assistant_content_blocks` and `tool_result_blocks` JSON `Vec<serde_json::Value>` variables built earlier (lines 349-375) are no longer needed for the message construction. However, they may still be useful for persistence (the messages stored in SQLite). Review whether they can be removed -- if they are only used in the two replaced `messages.push` calls, remove them. If they serve double duty (also used elsewhere), keep them.
  </action>
  <verify>
    <automated>cargo check -p blufio-agent 2>&1 | tail -5</automated>
  </verify>
  <done>Agent tool loop constructs ProviderMessages with structured ContentBlock::ToolUse and ContentBlock::ToolResult variants instead of JSON-serialized Text blocks. `cargo check` passes.</done>
</task>

</tasks>

<verification>
- `cargo check --workspace` passes with no errors
- ContentBlock enum has 4 variants: Text, Image, ToolUse, ToolResult
- convert_content_blocks handles all 4 variants
- Agent tool loop uses ContentBlock::ToolUse for assistant messages and ContentBlock::ToolResult for user messages
- No `serde_json::to_string(&assistant_content_blocks)` or `serde_json::to_string(&tool_result_blocks)` wrapping in the message push calls
</verification>

<success_criteria>
- Multi-turn tool conversations produce correct ToolUse/ToolResult content blocks
- The Anthropic API receives properly typed content blocks, not JSON-in-text
- `cargo check --workspace` passes
</success_criteria>

<output>
After completion, create `.planning/phases/11-fix-integration-bugs/11-01-SUMMARY.md`
</output>
