---
phase: 11-fix-integration-bugs
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - crates/blufio/src/serve.rs
autonomous: true
requirements: [SEC-03]

must_haves:
  truths:
    - vault_startup_check() is called during blufio serve startup before provider initialization
    - Vault-backed API keys are accessible to the Anthropic provider after startup
    - Startup aborts with clear error if vault exists but cannot be unlocked
    - Startup proceeds silently when no vault exists (most users)
  artifacts:
    - crates/blufio/src/serve.rs with vault_startup_check call before provider init
  key_links:
    - serve.rs calls blufio_vault::vault_startup_check before AnthropicProvider::new
    - vault_startup_check returns Option<Vault> -- None means no vault, Some means unlocked
---

<objective>
Fix P1: Wire vault_startup_check() into blufio serve startup sequence.

Purpose: The `vault_startup_check()` function exists in `blufio-vault` and is exported, but never called during `blufio serve`. This means vault-backed API keys (stored via `blufio config set-secret`) are never loaded, making the vault feature non-functional at runtime.

Output: serve.rs calls vault_startup_check() early in the startup sequence, before any component that needs secrets.
</objective>

<execution_context>
@/Users/suman/.claude/get-shit-done/workflows/execute-plan.md
@/Users/suman/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/STATE.md
@.planning/ROADMAP.md

<interfaces>
<!-- Key types the executor needs. -->

From crates/blufio-vault/src/lib.rs (exported public API):
```rust
pub use migration::{migrate_plaintext_secrets, vault_startup_check, MigrationReport};
pub use prompt::get_vault_passphrase;
pub use vault::{mask_secret, Vault};
```

From crates/blufio-vault/src/migration.rs (vault_startup_check signature):
```rust
pub async fn vault_startup_check(
    conn: tokio_rusqlite::Connection,
    config: &blufio_config::model::VaultConfig,
) -> Result<Option<Vault>, BlufioError> {
    // Returns None if no vault exists (silent no-op)
    // Returns Some(vault) if vault exists and was unlocked
    // Returns Err if vault exists but unlock fails
}
```

From crates/blufio/src/serve.rs (current startup order):
```rust
pub async fn run_serve(config: BlufioConfig) -> Result<(), BlufioError> {
    init_tracing(&config.agent.log_level);           // line ~79
    let _registry = initialize_plugin_registry(&config); // line ~84
    // ‚Üê vault check should go HERE
    let storage = SqliteStorage::new(config.storage.clone()); // line ~88-92
    // ... cost ledger, context engine, etc.
    let provider = AnthropicProvider::new(&config).await?;  // line ~152-161
}
```

From crates/blufio-config/src/model.rs (BlufioConfig has vault field):
```rust
pub struct BlufioConfig {
    pub vault: VaultConfig,
    // ... other fields
}
```
</interfaces>
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add vault_startup_check call to serve.rs startup</name>
  <files>crates/blufio/src/serve.rs</files>
  <action>
Add a `blufio_vault` import and insert the vault startup check call into `run_serve()`, immediately after the plugin registry initialization (line ~84) and before storage initialization (line ~87).

1. Add import at the top of the file (after the existing use statements around line 24-25):
```rust
#[cfg(feature = "vault")]
use blufio_vault::vault_startup_check;
```

2. Insert vault check between plugin registry init and storage init. After the line:
```rust
let _registry = initialize_plugin_registry(&config);
```

Add:
```rust
// SEC-03: Vault startup check -- unlock vault if it exists so secrets
// are available for provider initialization. Silent no-op when no vault.
#[cfg(feature = "vault")]
{
    let vault_conn = tokio_rusqlite::Connection::open(&config.storage.database_path)
        .await
        .map_err(|e| BlufioError::Storage { source: Box::new(e) })?;
    match vault_startup_check(vault_conn, &config.vault).await {
        Ok(Some(_vault)) => {
            info!("vault unlocked -- secrets available");
        }
        Ok(None) => {
            debug!("no vault found -- skipping vault startup check");
        }
        Err(e) => {
            error!(error = %e, "vault startup check failed");
            eprintln!(
                "error: Vault exists but cannot be unlocked. \
                 Set BLUFIO_VAULT_KEY environment variable or provide passphrase interactively."
            );
            return Err(e);
        }
    }
}
```

3. Check that `blufio` crate's `Cargo.toml` has the `vault` feature with the `blufio-vault` dependency. If not, the `#[cfg(feature = "vault")]` guard ensures clean compilation. Verify with:
```bash
grep -n "vault" crates/blufio/Cargo.toml
```
If `vault` feature does not exist, add it to the features table and add the dependency. But first check -- it likely exists since the project already has vault infrastructure.

NOTE: The vault check opens its own DB connection (separate from the storage connection created later). This is correct -- vault_startup_check needs a connection, and we haven't initialized storage yet. The connection is used internally by the Vault and can be dropped after the check since secrets are loaded into memory.
  </action>
  <verify>
    <automated>cargo check -p blufio 2>&1 | tail -5</automated>
  </verify>
  <done>serve.rs calls vault_startup_check before provider initialization. Startup aborts with clear error on vault unlock failure. Silent skip when no vault exists. `cargo check` passes.</done>
</task>

</tasks>

<verification>
- `cargo check --workspace` passes
- vault_startup_check is called before AnthropicProvider::new in the startup sequence
- Error path returns Err (aborts serve) with user-facing error message
- Ok(None) path is silent (debug log only)
- Ok(Some) path logs success at info level
</verification>

<success_criteria>
- `vault_startup_check()` is called during `blufio serve` startup
- Vault-backed API keys are usable after startup
- Startup aborts with clear error message if vault cannot be unlocked
- `cargo check --workspace` passes
</success_criteria>

<output>
After completion, create `.planning/phases/11-fix-integration-bugs/11-02-SUMMARY.md`
</output>
