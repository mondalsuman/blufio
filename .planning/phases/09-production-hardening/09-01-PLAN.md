---
phase: 09-production-hardening
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - crates/blufio-prometheus/src/recording.rs
  - crates/blufio-prometheus/src/lib.rs
  - crates/blufio-config/src/model.rs
  - crates/blufio/src/serve.rs
  - crates/blufio-gateway/src/server.rs
  - crates/blufio-gateway/src/handlers.rs
autonomous: true
requirements:
  - CORE-07
  - CORE-08
  - COST-04

must_haves:
  truths:
    - "Memory monitor background task runs every 5 seconds in serve mode, reads jemalloc heap via epoch::advance() + stats::allocated/resident, reads RSS via /proc/self/statm on Linux"
    - "Prometheus gauges blufio_memory_heap_bytes, blufio_memory_rss_bytes, blufio_memory_resident_bytes exported via existing metrics-rs facade"
    - "Prometheus counter blufio_errors_total with label 'type' tracks error rates"
    - "Memory warn+shed triggers at configurable threshold (default 150MB heap): logs warning, emits Prometheus gauge blufio_memory_pressure (0/1), clears jemalloc arenas via malloc_stats_print"
    - "DaemonConfig section in BlufioConfig with memory_warn_mb (default 150) and memory_limit_mb (default 200), health_port (default 3000)"
    - "GET /health endpoint on gateway returns JSON {status, uptime_secs, memory_heap_bytes, memory_rss_bytes, active_sessions} WITHOUT authentication"
    - "GET /metrics endpoint on gateway returns Prometheus text format WITHOUT authentication"
    - "Existing /v1/health remains authenticated and returns full health details"
  artifacts:
    - crates/blufio-prometheus/src/recording.rs
    - crates/blufio-gateway/src/server.rs
    - crates/blufio/src/serve.rs
    - crates/blufio-config/src/model.rs
  key_links:
    - "MemoryMonitor reads jemalloc stats and exports to Prometheus via metrics::gauge! macros"
    - "serve.rs spawns memory_monitor task with CancellationToken alongside heartbeat task"
    - "Gateway server.rs adds unauthenticated /health and /metrics routes outside auth middleware"
    - "PrometheusAdapter::render() called by /metrics handler to return text format"
---

<objective>
Add memory monitoring infrastructure, extend Prometheus metrics with memory/error gauges, and create unauthenticated health + metrics endpoints on the gateway.

Purpose: This is the foundation for all production hardening. The memory monitor provides the data that systemd health checks poll, that `blufio status` displays, and that Prometheus scrapes. The health endpoint enables systemd readiness verification without auth. Memory pressure detection prevents OOM on the $4/month VPS target.

Output: Memory monitor background task in serve.rs, new Prometheus gauges (heap, RSS, resident, error rate, memory pressure), DaemonConfig section in config model, unauthenticated /health and /metrics gateway routes.
</objective>

<execution_context>
@/Users/suman/.claude/get-shit-done/workflows/execute-plan.md
@/Users/suman/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/STATE.md
@.planning/ROADMAP.md
@.planning/phases/09-production-hardening/09-CONTEXT.md
@.planning/phases/09-production-hardening/09-RESEARCH.md

<interfaces>
<!-- Key types from existing codebase that this plan depends on -->

From crates/blufio-prometheus/src/recording.rs:
```rust
pub fn register_metrics() {
    describe_counter!("blufio_messages_total", "Total messages processed");
    describe_counter!("blufio_tokens_total", "Total tokens consumed");
    describe_gauge!("blufio_active_sessions", "Currently active sessions");
    describe_gauge!("blufio_budget_remaining_usd", "Remaining daily budget in USD");
    describe_histogram!("blufio_response_latency_seconds", "LLM response latency in seconds");
}
pub fn record_message(channel: &str) { ... }
pub fn record_tokens(model: &str, input: u32, output: u32) { ... }
pub fn set_active_sessions(count: f64) { ... }
pub fn set_budget_remaining(usd: f64) { ... }
pub fn record_latency(seconds: f64) { ... }
```

From crates/blufio-prometheus/src/lib.rs:
```rust
pub struct PrometheusAdapter { handle: PrometheusHandle }
impl PrometheusAdapter {
    pub fn new() -> Result<Self, BlufioError> { ... }
    pub fn render(&self) -> String { self.handle.render() }
}
```

From crates/blufio-gateway/src/server.rs:
```rust
pub struct GatewayState {
    pub inbound_tx: mpsc::Sender<InboundMessage>,
    pub response_map: Arc<DashMap<String, oneshot::Sender<String>>>,
    pub ws_senders: Arc<DashMap<String, mpsc::Sender<String>>>,
    pub auth: AuthConfig,
}
// Routes: POST /v1/messages (auth), GET /v1/sessions (auth), GET /v1/health (auth), GET /ws
```

From crates/blufio-config/src/model.rs:
```rust
pub struct BlufioConfig {
    pub agent: AgentConfig,
    pub telegram: TelegramConfig,
    pub anthropic: AnthropicConfig,
    pub storage: StorageConfig,
    pub security: SecurityConfig,
    pub vault: VaultConfig,
    pub cost: CostConfig,
    pub context: ContextConfig,
    pub memory: MemoryConfig,
    pub routing: RoutingConfig,
    pub heartbeat: HeartbeatConfig,
    pub skill: SkillConfig,
    pub plugin: PluginConfig,
    pub gateway: GatewayConfig,
    pub prometheus: PrometheusConfig,
}
```

From crates/blufio/src/serve.rs:
```rust
// shutdown::install_signal_handler() returns CancellationToken
// Heartbeat spawned with cancel.clone() for graceful shutdown
// Memory system initialized with jemalloc already as global allocator
```
</interfaces>
</context>

<tasks>

<task type="auto" tdd="true">
  <name>Task 1: Add DaemonConfig, extend Prometheus recording with memory/error metrics</name>
  <files>crates/blufio-config/src/model.rs, crates/blufio-prometheus/src/recording.rs, crates/blufio-prometheus/src/lib.rs</files>
  <behavior>
    - Test: DaemonConfig defaults to memory_warn_mb=150, memory_limit_mb=200, health_port=3000
    - Test: DaemonConfig deserializes from TOML with custom values
    - Test: BlufioConfig with new daemon section loads without error
    - Test: register_metrics() describes all new gauges (memory_heap_bytes, memory_rss_bytes, memory_resident_bytes, memory_pressure, errors_total)
    - Test: set_memory_heap/set_memory_rss/set_memory_resident/set_memory_pressure/record_error helper functions exist and accept correct types
  </behavior>
  <action>
1. In `crates/blufio-config/src/model.rs`:
   - Add `DaemonConfig` struct with `#[serde(deny_unknown_fields)]`:
     - `memory_warn_mb: u64` (default: 150) -- heap threshold for warning + cache shedding
     - `memory_limit_mb: u64` (default: 200) -- heap threshold for rejecting new sessions
     - `health_port: u16` (default: 3000) -- port for health endpoint (defaults to gateway port)
   - Add `#[serde(default)] pub daemon: DaemonConfig` to `BlufioConfig`
   - Implement `Default` for `DaemonConfig` with default functions

2. In `crates/blufio-prometheus/src/recording.rs`:
   - Add to `register_metrics()`:
     - `describe_gauge!("blufio_memory_heap_bytes", "jemalloc allocated heap bytes")`
     - `describe_gauge!("blufio_memory_rss_bytes", "Process RSS from /proc/self/statm")`
     - `describe_gauge!("blufio_memory_resident_bytes", "jemalloc resident bytes")`
     - `describe_gauge!("blufio_memory_pressure", "Memory pressure indicator (0=normal, 1=warning)")`
     - `describe_counter!("blufio_errors_total", "Total errors by type")`
   - Add helper functions:
     - `pub fn set_memory_heap(bytes: f64)` -- `metrics::gauge!("blufio_memory_heap_bytes").set(bytes)`
     - `pub fn set_memory_rss(bytes: f64)` -- `metrics::gauge!("blufio_memory_rss_bytes").set(bytes)`
     - `pub fn set_memory_resident(bytes: f64)` -- `metrics::gauge!("blufio_memory_resident_bytes").set(bytes)`
     - `pub fn set_memory_pressure(pressure: f64)` -- 0.0 or 1.0
     - `pub fn record_error(error_type: &str)` -- `metrics::counter!("blufio_errors_total", "type" => error_type.to_string()).increment(1)`

3. In `crates/blufio-prometheus/src/lib.rs`:
   - Add `pub use recording::{set_memory_heap, set_memory_rss, set_memory_resident, set_memory_pressure, record_error};` to the existing re-exports
  </action>
  <verify>
    <automated>cargo test -p blufio-config -- daemon && cargo test -p blufio-prometheus</automated>
  </verify>
  <done>DaemonConfig exists in BlufioConfig with memory thresholds. All new Prometheus metric helpers compile and are re-exported. Config deserializes with and without [daemon] section.</done>
</task>

<task type="auto" tdd="true">
  <name>Task 2: Add memory monitor task to serve.rs and unauthenticated /health + /metrics gateway routes</name>
  <files>crates/blufio/src/serve.rs, crates/blufio-gateway/src/server.rs, crates/blufio-gateway/src/handlers.rs</files>
  <behavior>
    - Test: Gateway /health route exists and returns 200 with JSON containing status, uptime_secs fields
    - Test: Gateway /health route is NOT behind auth middleware
    - Test: Gateway /metrics route exists and is NOT behind auth middleware
    - Test: HealthState struct is Clone and contains Arc fields for shared health data
  </behavior>
  <action>
1. In `crates/blufio-gateway/src/server.rs`:
   - Add `HealthState` struct:
     ```rust
     #[derive(Clone)]
     pub struct HealthState {
         pub start_time: std::time::Instant,
         pub prometheus_handle: Option<Arc<dyn Fn() -> String + Send + Sync>>,
     }
     ```
   - Modify `GatewayState` to include `pub health: HealthState`
   - In `start_server()`, add unauthenticated routes BEFORE the auth-protected routes:
     ```rust
     let public_routes = Router::new()
         .route("/health", get(handlers::get_public_health))
         .route("/metrics", get(handlers::get_public_metrics))
         .with_state(state.clone());
     ```
   - Merge public_routes into the app router alongside api_routes and ws_routes

2. In `crates/blufio-gateway/src/handlers.rs`:
   - Add `get_public_health` handler:
     ```rust
     pub async fn get_public_health(State(state): State<GatewayState>) -> impl IntoResponse {
         let uptime = state.health.start_time.elapsed().as_secs();
         let body = serde_json::json!({
             "status": "healthy",
             "uptime_secs": uptime,
         });
         (StatusCode::OK, axum::Json(body))
     }
     ```
   - Add `get_public_metrics` handler:
     ```rust
     pub async fn get_public_metrics(State(state): State<GatewayState>) -> impl IntoResponse {
         match &state.health.prometheus_handle {
             Some(render_fn) => {
                 let body = render_fn();
                 (StatusCode::OK, [(axum::http::header::CONTENT_TYPE, "text/plain; version=0.0.4")], body).into_response()
             }
             None => (StatusCode::SERVICE_UNAVAILABLE, "Metrics not available").into_response(),
         }
     }
     ```

3. In `crates/blufio/src/serve.rs`:
   - Add `memory_monitor` async function:
     ```rust
     async fn memory_monitor(
         config: &blufio_config::model::DaemonConfig,
         cancel: tokio_util::sync::CancellationToken,
     ) {
         let warn_bytes = config.memory_warn_mb as usize * 1024 * 1024;
         let mut interval = tokio::time::interval(Duration::from_secs(5));
         loop {
             tokio::select! {
                 _ = interval.tick() => {
                     // Read jemalloc stats
                     tikv_jemalloc_ctl::epoch::advance().unwrap();
                     let allocated = tikv_jemalloc_ctl::stats::allocated::read().unwrap_or(0);
                     let resident = tikv_jemalloc_ctl::stats::resident::read().unwrap_or(0);

                     // Read RSS (Linux only, graceful fallback)
                     let rss = read_rss_bytes().unwrap_or(0);

                     // Export to Prometheus
                     blufio_prometheus::set_memory_heap(allocated as f64);
                     blufio_prometheus::set_memory_resident(resident as f64);
                     blufio_prometheus::set_memory_rss(rss as f64);

                     // Check thresholds
                     if allocated > warn_bytes {
                         warn!(allocated_mb = allocated / (1024*1024), "memory pressure: heap above warning threshold");
                         blufio_prometheus::set_memory_pressure(1.0);
                         // Shed: purge jemalloc dirty pages
                         let _ = tikv_jemalloc_ctl::raw::write(b"arena.0.purge\0", &0u64 as *const _ as *const _, std::mem::size_of::<u64>());
                     } else {
                         blufio_prometheus::set_memory_pressure(0.0);
                     }
                 }
                 _ = cancel.cancelled() => {
                     info!("memory monitor shutting down");
                     break;
                 }
             }
         }
     }

     fn read_rss_bytes() -> Option<u64> {
         #[cfg(target_os = "linux")]
         {
             let statm = std::fs::read_to_string("/proc/self/statm").ok()?;
             let rss_pages = statm.split_whitespace().nth(1)?.parse::<u64>().ok()?;
             Some(rss_pages * 4096)
         }
         #[cfg(not(target_os = "linux"))]
         {
             None // RSS reading not supported on this platform
         }
     }
     ```
   - In `run_serve()`, after signal handler installation, spawn memory monitor:
     ```rust
     let daemon_config = config.daemon.clone();
     let mem_cancel = cancel.clone();
     tokio::spawn(async move {
         memory_monitor(&daemon_config, mem_cancel).await;
     });
     ```
   - When creating GatewayChannelConfig, also create HealthState with start_time = Instant::now() and prometheus_handle from PrometheusAdapter (if enabled). Pass prometheus render function as Arc closure:
     ```rust
     let prometheus_render: Option<Arc<dyn Fn() -> String + Send + Sync>> =
         _prometheus_adapter.as_ref().map(|a| {
             let handle = a.handle().clone();
             Arc::new(move || handle.render()) as Arc<dyn Fn() -> String + Send + Sync>
         });
     ```
   - Pass HealthState into GatewayChannel (extend GatewayChannelConfig or pass separately)
  </action>
  <verify>
    <automated>cargo test -p blufio-gateway && cargo build -p blufio</automated>
  </verify>
  <done>Memory monitor task spawns in serve mode and exports jemalloc stats to Prometheus every 5s. Gateway has unauthenticated /health returning JSON and /metrics returning Prometheus text. Health endpoint responds without bearer token. Binary compiles successfully.</done>
</task>

</tasks>

<verification>
- `cargo build -p blufio` succeeds with all features
- `cargo test -p blufio-config` passes (DaemonConfig tests)
- `cargo test -p blufio-prometheus` passes (metric helper tests)
- `cargo test -p blufio-gateway` passes (health endpoint tests)
- New Prometheus gauges registered: blufio_memory_heap_bytes, blufio_memory_rss_bytes, blufio_memory_resident_bytes, blufio_memory_pressure
- New Prometheus counter registered: blufio_errors_total
- /health returns JSON without auth
- /metrics returns Prometheus text without auth
</verification>

<success_criteria>
- DaemonConfig with memory_warn_mb and memory_limit_mb exists in BlufioConfig
- Memory monitor background task compiles and spawns in serve.rs
- All 5 new Prometheus metric helpers (heap, rss, resident, pressure, errors) exist and are re-exported
- Gateway /health and /metrics routes are unauthenticated
- `cargo build -p blufio` completes without errors
</success_criteria>

<output>
After completion, create `.planning/phases/09-production-hardening/09-01-SUMMARY.md`
</output>
