---
phase: 09-production-hardening
plan: 03
type: execute
wave: 2
depends_on: [09-01]
files_modified:
  - crates/blufio/src/main.rs
  - crates/blufio/src/backup.rs
  - crates/blufio/Cargo.toml
autonomous: true
requirements:
  - CLI-08

must_haves:
  truths:
    - "`blufio backup <path>` creates an atomic backup of the SQLite database to the specified path using rusqlite's Backup API"
    - "`blufio restore <path>` restores the database from a backup file, replacing the current database"
    - "Backup uses rusqlite::backup::Backup::new() with page stepping (100 pages per step, 10ms sleep) for non-blocking operation"
    - "Backup reports progress: 'Backup complete: 1.2 MB written to /path/to/backup.db'"
    - "Restore validates the source file exists and is a valid SQLite database before replacing"
    - "Restore creates a backup of the current DB before overwriting (safety net)"
    - "Both backup and restore work with WAL mode enabled"
    - "Vault data is included in backup (stored in same SQLite file)"
  artifacts:
    - crates/blufio/src/backup.rs
    - crates/blufio/src/main.rs
  key_links:
    - "backup.rs uses rusqlite::backup::Backup for atomic page-by-page copy"
    - "main.rs Commands::Backup/Restore wire to backup::run_backup/run_restore"
    - "Backup opens source DB in read-only mode to avoid conflicts with running instance"
---

<objective>
Implement `blufio backup` and `blufio restore` CLI commands using SQLite's backup API for atomic database operations.

Purpose: Reliable backup/restore is essential for production operations. The SQLite backup API provides atomic, consistent copies even while the database is being written to (WAL mode). Since the vault is stored in the same SQLite file, backup automatically includes encrypted credentials.

Output: New backup.rs module with run_backup and run_restore functions. Commands::Backup and Commands::Restore wired in main.rs.
</objective>

<execution_context>
@/Users/suman/.claude/get-shit-done/workflows/execute-plan.md
@/Users/suman/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/STATE.md
@.planning/ROADMAP.md
@.planning/phases/09-production-hardening/09-CONTEXT.md
@.planning/phases/09-production-hardening/09-RESEARCH.md

<interfaces>
<!-- Key types from existing codebase -->

From crates/blufio-config/src/model.rs:
```rust
pub struct StorageConfig {
    pub database_path: String,
    pub wal_mode: bool,
}
```

From crates/blufio/src/main.rs (after Plan 02):
```rust
enum Commands {
    Serve, Shell, Status { ... }, Doctor { ... },
    Config { action: Option<ConfigCommands> },
    Skill { action: SkillCommands },
    Plugin { action: PluginCommands },
    Backup { path: String },
    Restore { path: String },
}
```

rusqlite backup API:
```rust
use rusqlite::{Connection, backup::Backup};
// Backup::new(&src_conn, &mut dst_conn) -> Result<Backup>
// backup.run_to_completion(pages_per_step, sleep_between_steps, progress_callback) -> Result<()>
```
</interfaces>
</context>

<tasks>

<task type="auto" tdd="true">
  <name>Task 1: Implement backup module with SQLite backup API</name>
  <files>crates/blufio/src/backup.rs, crates/blufio/Cargo.toml</files>
  <behavior>
    - Test: run_backup creates a valid SQLite database at the destination path
    - Test: run_backup of an empty DB succeeds and destination is openable
    - Test: run_restore from a valid backup file replaces the target DB
    - Test: run_restore creates a .pre-restore backup of the current DB before overwriting
    - Test: run_restore fails with a clear error if source file doesn't exist
    - Test: run_restore fails with a clear error if source file is not a valid SQLite DB
  </behavior>
  <action>
1. Ensure `rusqlite` is a direct dependency of the `blufio` binary crate. Check `crates/blufio/Cargo.toml` -- rusqlite may not be listed (it's used via blufio-storage). Add if needed:
   ```toml
   rusqlite = { workspace = true }
   ```

2. Create `crates/blufio/src/backup.rs`:
   ```rust
   use std::path::Path;
   use std::time::Duration;
   use rusqlite::Connection;
   use blufio_core::BlufioError;

   /// Run a backup of the SQLite database to the specified path.
   ///
   /// Uses rusqlite's Backup API for atomic, consistent copies that work
   /// even while the database is being written to in WAL mode.
   pub fn run_backup(db_path: &str, backup_path: &str) -> Result<(), BlufioError> {
       let src_path = Path::new(db_path);
       if !src_path.exists() {
           return Err(BlufioError::Storage {
               source: Box::new(std::io::Error::new(
                   std::io::ErrorKind::NotFound,
                   format!("database not found: {db_path}"),
               )),
           });
       }

       // Open source in read-only mode to minimize impact on running instance
       let src = Connection::open_with_flags(
           db_path,
           rusqlite::OpenFlags::SQLITE_OPEN_READ_ONLY | rusqlite::OpenFlags::SQLITE_OPEN_NO_MUTEX,
       ).map_err(|e| BlufioError::Storage { source: Box::new(e) })?;

       let mut dst = Connection::open(backup_path)
           .map_err(|e| BlufioError::Storage { source: Box::new(e) })?;

       let backup = rusqlite::backup::Backup::new(&src, &mut dst)
           .map_err(|e| BlufioError::Storage { source: Box::new(e) })?;

       // Copy 100 pages per step, sleep 10ms between steps
       // This allows the running instance to continue writing
       backup.run_to_completion(100, Duration::from_millis(10), None)
           .map_err(|e| BlufioError::Storage { source: Box::new(e) })?;

       // Report file size
       let metadata = std::fs::metadata(backup_path)
           .map_err(|e| BlufioError::Storage { source: Box::new(e) })?;
       let size_mb = metadata.len() as f64 / (1024.0 * 1024.0);
       eprintln!("Backup complete: {size_mb:.1} MB written to {backup_path}");

       Ok(())
   }

   /// Restore the database from a backup file.
   ///
   /// Creates a safety backup of the current DB before overwriting.
   /// Validates that the source is a valid SQLite database.
   pub fn run_restore(db_path: &str, restore_from: &str) -> Result<(), BlufioError> {
       let src_path = Path::new(restore_from);
       if !src_path.exists() {
           return Err(BlufioError::Storage {
               source: Box::new(std::io::Error::new(
                   std::io::ErrorKind::NotFound,
                   format!("backup file not found: {restore_from}"),
               )),
           });
       }

       // Validate source is a valid SQLite DB
       let test_conn = Connection::open_with_flags(
           restore_from,
           rusqlite::OpenFlags::SQLITE_OPEN_READ_ONLY,
       ).map_err(|e| BlufioError::Storage { source: Box::new(e) })?;

       // Quick validation: can we query it?
       test_conn.execute_batch("SELECT 1")
           .map_err(|e| BlufioError::Storage { source: Box::new(e) })?;
       drop(test_conn);

       // Create safety backup of current DB (if it exists)
       let dst_path = Path::new(db_path);
       if dst_path.exists() {
           let pre_restore_path = format!("{db_path}.pre-restore");
           eprintln!("Creating safety backup: {pre_restore_path}");
           run_backup(db_path, &pre_restore_path)?;
       }

       // Perform restore using backup API (reverse direction)
       let src = Connection::open_with_flags(
           restore_from,
           rusqlite::OpenFlags::SQLITE_OPEN_READ_ONLY,
       ).map_err(|e| BlufioError::Storage { source: Box::new(e) })?;

       let mut dst = Connection::open(db_path)
           .map_err(|e| BlufioError::Storage { source: Box::new(e) })?;

       let backup = rusqlite::backup::Backup::new(&src, &mut dst)
           .map_err(|e| BlufioError::Storage { source: Box::new(e) })?;

       backup.run_to_completion(100, Duration::from_millis(10), None)
           .map_err(|e| BlufioError::Storage { source: Box::new(e) })?;

       let metadata = std::fs::metadata(db_path)
           .map_err(|e| BlufioError::Storage { source: Box::new(e) })?;
       let size_mb = metadata.len() as f64 / (1024.0 * 1024.0);
       eprintln!("Restore complete: {size_mb:.1} MB restored from {restore_from}");

       Ok(())
   }
   ```

3. In `crates/blufio/src/main.rs`:
   - Add `mod backup;`
   - Wire up in main match:
     ```rust
     Some(Commands::Backup { path }) => {
         if let Err(e) = backup::run_backup(&config.storage.database_path, &path) {
             eprintln!("error: {e}");
             std::process::exit(1);
         }
     }
     Some(Commands::Restore { path }) => {
         if let Err(e) = backup::run_restore(&config.storage.database_path, &path) {
             eprintln!("error: {e}");
             std::process::exit(1);
         }
     }
     ```
  </action>
  <verify>
    <automated>cargo test -p blufio -- backup && cargo build -p blufio</automated>
  </verify>
  <done>Backup creates atomic copy via SQLite backup API. Restore validates source, creates safety backup, then overwrites. Both report file size. Tests pass with temp directories. Binary compiles.</done>
</task>

</tasks>

<verification>
- `cargo build -p blufio` succeeds
- `cargo test -p blufio -- backup` passes (backup/restore roundtrip with temp dirs)
- Backup creates valid SQLite file at target path
- Restore creates .pre-restore safety backup before overwriting
- Restore rejects non-existent or invalid source files
- WAL mode compatibility verified (backup works with WAL-mode source)
</verification>

<success_criteria>
- `blufio backup <path>` creates atomic SQLite backup with progress reporting
- `blufio restore <path>` validates, safety-backups, then restores
- Vault data included in backup (same SQLite file)
- All tests pass, binary compiles
</success_criteria>

<output>
After completion, create `.planning/phases/09-production-hardening/09-03-SUMMARY.md`
</output>
