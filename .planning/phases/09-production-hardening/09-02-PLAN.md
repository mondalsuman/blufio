---
phase: 09-production-hardening
plan: 02
type: execute
wave: 2
depends_on: [09-01]
files_modified:
  - crates/blufio/src/main.rs
  - crates/blufio/src/status.rs
  - crates/blufio/src/doctor.rs
  - contrib/blufio.service
  - contrib/blufio-logrotate.conf
autonomous: true
requirements:
  - CLI-02
  - CLI-03
  - CLI-04
  - CLI-07
  - SEC-02
  - CORE-04

must_haves:
  truths:
    - "`blufio status` connects to /health endpoint, displays agent state, uptime, active sessions, memory usage, cost summary; falls back to offline message if unreachable"
    - "`blufio status --json` outputs the same data as structured JSON for scripting"
    - "`blufio doctor` runs quick checks in ~2s: LLM API connectivity (HEAD to api.anthropic.com), DB file exists + opens, Telegram token format, gateway health endpoint"
    - "`blufio doctor --deep` adds: DB integrity (PRAGMA integrity_check), disk space, memory baseline (jemalloc stats), vault existence check (~10-15s)"
    - "`blufio config get <key>` prints the current resolved config value for a dotted key path"
    - "`blufio config validate` loads blufio.toml and reports all validation errors or success"
    - "CLI output uses colored crate with TTY detection: green checkmarks for pass, red X's for fail; auto-plain when piped; --plain flag forces plain"
    - "contrib/blufio.service is a systemd unit file with Type=simple, Restart=on-failure, RestartSec=5s, security hardening, ExecStartPost health poll"
    - "contrib/blufio-logrotate.conf is a logrotate config for syslog setups"
    - "SEC-02 enforced: keypair auth adapter is required in serve mode, no optional auth mode"
  artifacts:
    - crates/blufio/src/status.rs
    - crates/blufio/src/doctor.rs
    - crates/blufio/src/main.rs
    - contrib/blufio.service
    - contrib/blufio-logrotate.conf
  key_links:
    - "`blufio status` queries GET /health endpoint from Plan 01, formats output with colored crate"
    - "`blufio doctor` checks reuse config loader, storage opener, and HTTP client patterns already in codebase"
    - "`blufio config get` loads config via blufio_config::load_and_validate() then traverses by key path"
    - "systemd unit file ExecStartPost polls the /health endpoint created in Plan 01"
---

<objective>
Add CLI diagnostics (status, doctor, config get/validate), systemd unit file, logrotate config, and enforce device keypair auth.

Purpose: These are the operator-facing tools that make blufio manageable in production. `status` gives at-a-glance health, `doctor` diagnoses problems, `config get/validate` prevents misconfigurations, and the systemd unit file enables daemon management. SEC-02 enforcement ensures keypair auth is always active.

Output: New `status.rs` and `doctor.rs` modules, extended Commands enum with Status/Doctor/Backup/Restore, updated Config subcommands with get/validate, contrib/ directory with systemd service file and logrotate config.
</objective>

<execution_context>
@/Users/suman/.claude/get-shit-done/workflows/execute-plan.md
@/Users/suman/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/STATE.md
@.planning/ROADMAP.md
@.planning/phases/09-production-hardening/09-CONTEXT.md
@.planning/phases/09-production-hardening/09-RESEARCH.md

<interfaces>
<!-- Key types from Plan 01 outputs that this plan depends on -->

From Plan 01 - Gateway /health endpoint response:
```json
{
  "status": "healthy",
  "uptime_secs": 12345
}
```

From Plan 01 - DaemonConfig in blufio-config:
```rust
pub struct DaemonConfig {
    pub memory_warn_mb: u64,   // default 150
    pub memory_limit_mb: u64,  // default 200
    pub health_port: u16,      // default 3000
}
```

From crates/blufio/src/main.rs:
```rust
enum Commands {
    Serve, Shell,
    Config { action: Option<ConfigCommands> },
    Skill { action: SkillCommands },
    Plugin { action: PluginCommands },
}
enum ConfigCommands { SetSecret { key: String }, ListSecrets }
```

From crates/blufio-config/src/model.rs:
```rust
pub struct BlufioConfig { /* all sections with defaults */ }
// load_and_validate() -> Result<BlufioConfig, Vec<BlufioError>>
```

From crates/blufio-auth-keypair/src/lib.rs:
```rust
pub struct KeypairAuthAdapter { keypair: DeviceKeypair }
impl KeypairAuthAdapter {
    pub fn new(keypair: DeviceKeypair) -> Self { ... }
}
impl AuthAdapter for KeypairAuthAdapter {
    async fn authenticate(&self, token: AuthToken) -> Result<AuthIdentity, BlufioError> { ... }
}
```
</interfaces>
</context>

<tasks>

<task type="auto" tdd="true">
  <name>Task 1: Add Status, Doctor, Config get/validate CLI subcommands</name>
  <files>crates/blufio/src/main.rs, crates/blufio/src/status.rs, crates/blufio/src/doctor.rs</files>
  <behavior>
    - Test: CLI parses `blufio status` into Commands::Status { json: false, plain: false }
    - Test: CLI parses `blufio status --json` into Commands::Status { json: true, plain: false }
    - Test: CLI parses `blufio status --plain` into Commands::Status { json: false, plain: true }
    - Test: CLI parses `blufio doctor` into Commands::Doctor { deep: false, plain: false }
    - Test: CLI parses `blufio doctor --deep` into Commands::Doctor { deep: true, plain: false }
    - Test: CLI parses `blufio config get agent.name` into ConfigCommands::Get { key }
    - Test: CLI parses `blufio config validate` into ConfigCommands::Validate
    - Test: CheckResult struct has name, status (Pass/Warn/Fail), message, duration fields
    - Test: config_get for "agent.name" returns "blufio" from default config
  </behavior>
  <action>
1. Create `crates/blufio/src/status.rs`:
   - `pub async fn run_status(config: &BlufioConfig, json: bool, plain: bool) -> Result<(), BlufioError>`
   - Build health URL from `config.gateway.host` and `config.gateway.port` (or `config.daemon.health_port`)
   - Use `reqwest::Client::builder().timeout(Duration::from_secs(3)).build()` to call GET /health
   - If reachable: parse JSON response, also query CostLedger for today/month costs
   - If unreachable: display "Agent not running" with last-known DB info
   - For `--json` mode: output serde_json::to_string_pretty of a StatusResponse struct
   - For default mode: use colored crate:
     ```
     blufio status
     ─────────────────────────────────
       State:    ✓ running (uptime: 2h 15m)
       Sessions: 3 active
       Memory:   45.2 MB heap / 128.5 MB RSS
       Cost:     $0.12 today / $2.34 this month
       Channels: telegram ✓, gateway ✓
     ```
   - Use `std::io::IsTerminal` for auto-plain detection; `--plain` forces plain output

2. Create `crates/blufio/src/doctor.rs`:
   - Define `CheckStatus` enum: Pass, Warn, Fail
   - Define `CheckResult { name: String, status: CheckStatus, message: String, duration: Duration }`
   - `pub async fn run_doctor(config: &BlufioConfig, deep: bool, plain: bool) -> Result<(), BlufioError>`
   - Quick checks (always run):
     - `check_config()` -- loads config, reports errors if any
     - `check_database(path)` -- opens SQLite, runs `SELECT 1`, measures time
     - `check_llm_connectivity(config)` -- HTTP HEAD to `https://api.anthropic.com/v1/messages` with API key, timeout 5s
     - `check_health_endpoint(config)` -- GET /health on gateway, timeout 3s
   - Deep checks (`--deep` only):
     - `check_db_integrity(path)` -- `PRAGMA integrity_check`
     - `check_disk_space()` -- check free space on DB partition (use std::fs::metadata for size, warn if <100MB free -- simple heuristic)
     - `check_memory_baseline()` -- read jemalloc stats, report current heap/resident
     - `check_vault(config)` -- check if vault table exists in DB
   - Format output with colored symbols:
     ```
     blufio doctor
     ─────────────────────────────────
       ✓ Configuration    valid (0ms)
       ✓ Database         connected (2ms)
       ✓ LLM API          reachable (245ms)
       ✗ Health endpoint   not reachable (3001ms)

     1 issue found. Run with --deep for detailed diagnostics.
     ```
   - Each check has a 10s timeout via `tokio::time::timeout`

3. In `crates/blufio/src/main.rs`:
   - Add `mod status; mod doctor;`
   - Extend `Commands` enum:
     ```rust
     Status {
         #[arg(long)] json: bool,
         #[arg(long)] plain: bool,
     },
     Doctor {
         #[arg(long)] deep: bool,
         #[arg(long)] plain: bool,
     },
     Backup { path: String },
     Restore { path: String },
     ```
   - Extend `ConfigCommands` enum:
     ```rust
     Get { key: String },
     Validate,
     ```
   - Wire up handlers in main():
     - `Commands::Status { json, plain }` -> `status::run_status(&config, json, plain).await`
     - `Commands::Doctor { deep, plain }` -> `doctor::run_doctor(&config, deep, plain).await`
     - `ConfigCommands::Get { key }` -> `cmd_config_get(&config, &key)` -- synchronous, traverses config struct fields by key path using match on known dotted paths (agent.name, agent.log_level, storage.database_path, etc.)
     - `ConfigCommands::Validate` -> load_and_validate() and print result
   - For `cmd_config_get`: implement as match statement covering top-level sections:
     ```rust
     fn cmd_config_get(config: &BlufioConfig, key: &str) -> Result<(), BlufioError> {
         let value = match key {
             "agent.name" => config.agent.name.clone(),
             "agent.log_level" => config.agent.log_level.clone(),
             "storage.database_path" => config.storage.database_path.clone(),
             // ... cover all commonly-queried keys
             _ => return Err(BlufioError::Config(format!("unknown config key: {key}"))),
         };
         println!("{value}");
         Ok(())
     }
     ```
     Alternatively, serialize config to serde_json::Value and traverse by splitting key on ".".
   - Backup/Restore placeholders: add the command variants now, implement in Plan 03
  </action>
  <verify>
    <automated>cargo test -p blufio -- cli_parses && cargo test -p blufio -- doctor && cargo test -p blufio -- status && cargo test -p blufio -- config_get && cargo build -p blufio</automated>
  </verify>
  <done>All new CLI subcommands parse correctly. Status module connects to health endpoint and formats output. Doctor runs quick checks with colored output. Config get resolves known keys. Config validate loads and reports. Binary compiles.</done>
</task>

<task type="auto">
  <name>Task 2: Create systemd unit file, logrotate config, and enforce SEC-02 keypair auth</name>
  <files>contrib/blufio.service, contrib/blufio-logrotate.conf, contrib/hooks/pre-start.sh, contrib/hooks/post-stop.sh, crates/blufio/src/serve.rs</files>
  <action>
1. Create `contrib/` directory structure:
   ```
   contrib/
   ├── blufio.service
   ├── blufio-logrotate.conf
   └── hooks/
       ├── pre-start.sh
       └── post-stop.sh
   ```

2. Create `contrib/blufio.service`:
   ```ini
   # Blufio AI Agent - systemd service unit
   # Install: cp contrib/blufio.service /etc/systemd/system/
   # Enable:  systemctl enable blufio && systemctl start blufio

   [Unit]
   Description=Blufio AI Agent
   Documentation=https://github.com/blufio/blufio
   After=network-online.target
   Wants=network-online.target

   [Service]
   Type=simple
   ExecStartPre=-/var/lib/blufio/hooks/pre-start.sh
   ExecStart=/usr/local/bin/blufio serve
   ExecStartPost=/bin/sh -c 'for i in $(seq 1 15); do curl -sf http://127.0.0.1:3000/health > /dev/null 2>&1 && exit 0; sleep 1; done; exit 1'
   ExecStopPost=-/var/lib/blufio/hooks/post-stop.sh
   Restart=on-failure
   RestartSec=5s
   StartLimitBurst=3
   StartLimitIntervalSec=60
   TimeoutStopSec=30

   User=blufio
   Group=blufio
   WorkingDirectory=/var/lib/blufio

   Environment=RUST_LOG=blufio=info
   EnvironmentFile=-/etc/blufio/environment

   # Security hardening
   NoNewPrivileges=yes
   PrivateTmp=yes
   PrivateDevices=yes
   ProtectSystem=strict
   ProtectHome=yes
   ReadWritePaths=/var/lib/blufio
   ProtectKernelTunables=yes
   ProtectKernelModules=yes
   RestrictAddressFamilies=AF_UNIX AF_INET AF_INET6
   LimitNOFILE=65536

   # Memory limit (systemd-level protection)
   MemoryMax=256M
   MemoryHigh=200M

   [Install]
   WantedBy=multi-user.target
   ```

3. Create `contrib/blufio-logrotate.conf`:
   ```
   # Blufio log rotation (for syslog setups, not journald)
   # Install: cp contrib/blufio-logrotate.conf /etc/logrotate.d/blufio
   #
   # Note: Blufio logs to stdout/stderr by default.
   # With systemd, logs go to journald (no rotation needed).
   # This config is for setups redirecting to a file via syslog.

   /var/log/blufio/*.log {
       daily
       rotate 14
       compress
       delaycompress
       missingok
       notifempty
       copytruncate
       maxsize 50M
   }
   ```

4. Create `contrib/hooks/pre-start.sh`:
   ```bash
   #!/bin/sh
   # Blufio pre-start lifecycle hook
   # Called by systemd ExecStartPre before blufio starts.
   # Customize for your deployment (e.g., DB backup, config check).

   set -e

   # Ensure data directory exists
   mkdir -p /var/lib/blufio

   # Optional: validate config before starting
   # /usr/local/bin/blufio config validate || exit 1

   echo "blufio: pre-start hook complete"
   ```

5. Create `contrib/hooks/post-stop.sh`:
   ```bash
   #!/bin/sh
   # Blufio post-stop lifecycle hook
   # Called by systemd ExecStopPost after blufio stops.
   # Customize for your deployment (e.g., backup, notification).

   echo "blufio: post-stop hook complete (exit code: $EXIT_STATUS)"
   ```

6. In `crates/blufio/src/serve.rs` -- enforce SEC-02 (keypair auth required):
   - After gateway initialization, verify that keypair auth is available:
     ```rust
     // SEC-02: Device keypair authentication is required
     #[cfg(feature = "keypair")]
     {
         if config.gateway.enabled && config.gateway.bearer_token.is_none() {
             warn!("gateway enabled without bearer_token -- keypair auth will be used");
         }
         info!("keypair auth available (SEC-02)");
     }
     #[cfg(not(feature = "keypair"))]
     {
         if config.gateway.enabled {
             return Err(BlufioError::Security(
                 "SEC-02: device keypair authentication is required but keypair feature is disabled".to_string()
             ));
         }
     }
     ```
   - This ensures the binary cannot run the gateway without the keypair feature enabled
  </action>
  <verify>
    <automated>test -f contrib/blufio.service && test -f contrib/blufio-logrotate.conf && test -f contrib/hooks/pre-start.sh && test -f contrib/hooks/post-stop.sh && cargo build -p blufio && echo "OK"</automated>
  </verify>
  <done>contrib/blufio.service exists with Type=simple, Restart=on-failure, security hardening, and health poll ExecStartPost. Logrotate config exists. Lifecycle hook scripts exist and are executable. SEC-02 enforced: keypair feature required when gateway enabled. Binary compiles.</done>
</task>

</tasks>

<verification>
- `cargo build -p blufio` succeeds
- `cargo test -p blufio` passes all new CLI parsing tests
- `blufio status --help` shows --json and --plain flags
- `blufio doctor --help` shows --deep and --plain flags
- `blufio config get agent.name` prints "blufio" (from defaults)
- `blufio config validate` reports success with defaults
- contrib/blufio.service has Restart=on-failure and ExecStartPost health poll
- SEC-02: compile without keypair feature fails if gateway enabled
</verification>

<success_criteria>
- Status command displays agent health or offline message
- Doctor command runs quick checks with colored pass/fail output
- Config get resolves known dotted key paths
- Config validate loads TOML and reports errors
- systemd unit file in contrib/ with security hardening
- Logrotate and lifecycle hook scripts in contrib/
- SEC-02 enforced at compile/runtime
</success_criteria>

<output>
After completion, create `.planning/phases/09-production-hardening/09-02-SUMMARY.md`
</output>
