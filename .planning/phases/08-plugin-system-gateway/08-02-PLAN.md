---
phase: 08-plugin-system-gateway
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - Cargo.toml
  - crates/blufio-gateway/Cargo.toml
  - crates/blufio-gateway/src/lib.rs
  - crates/blufio-gateway/src/server.rs
  - crates/blufio-gateway/src/handlers.rs
  - crates/blufio-gateway/src/ws.rs
  - crates/blufio-gateway/src/sse.rs
  - crates/blufio-gateway/src/auth.rs
  - crates/blufio-config/src/model.rs
autonomous: true
requirements:
  - INFRA-05

must_haves:
  truths:
    - "GatewayChannel implements ChannelAdapter trait with receive() returning InboundMessages from HTTP/WebSocket clients"
    - "POST /v1/messages accepts JSON body with message content, creates InboundMessage, returns response after agent processes it"
    - "POST /v1/messages with Accept: text/event-stream returns SSE response streaming partial content as the agent generates it"
    - "GET /v1/sessions lists active sessions with session_id, channel, state, created_at"
    - "GET /v1/health returns 200 with JSON health status"
    - "WebSocket at /ws supports bidirectional messaging: client sends JSON messages, server streams JSON responses with typing indicators"
    - "Bearer token authentication middleware rejects requests without valid Authorization header"
    - "GatewayConfig added to BlufioConfig with port, host, bearer_token, and enabled flag"
    - "axum server runs in a background tokio task, not blocking the channel receive loop"
    - "Response routing uses DashMap<request_id, oneshot::Sender> so HTTP handlers receive responses from the agent loop"
  artifacts:
    - crates/blufio-gateway/src/lib.rs
    - crates/blufio-gateway/src/server.rs
    - crates/blufio-gateway/src/handlers.rs
    - crates/blufio-gateway/src/ws.rs
    - crates/blufio-gateway/src/auth.rs
  key_links:
    - "GatewayChannel::receive() reads from mpsc::Receiver populated by axum handlers"
    - "GatewayChannel::send() looks up oneshot sender in response_map and delivers response"
    - "axum handlers create InboundMessage with channel='api' or channel='ws' and push to inbound_tx"
    - "auth middleware extracts Bearer token from Authorization header, validates against config or vault"
---

<objective>
Create the blufio-gateway crate implementing an HTTP/WebSocket gateway as a ChannelAdapter. The gateway provides REST API access (POST /v1/messages, GET /v1/sessions, GET /v1/health), SSE streaming, WebSocket bidirectional messaging, and bearer token authentication -- all on a single axum server.

Purpose: Enable API access to the Blufio agent alongside Telegram. By implementing ChannelAdapter, the gateway reuses the entire agent loop, session management, context engine, and tool pipeline. The gateway enables programmatic interaction, web UIs, and third-party integrations.

Output: New blufio-gateway crate with GatewayChannel (ChannelAdapter), axum server with REST/WebSocket/SSE endpoints, bearer token auth middleware, and GatewayConfig in BlufioConfig.
</objective>

<execution_context>
@/Users/suman/.claude/get-shit-done/workflows/execute-plan.md
@/Users/suman/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/STATE.md
@.planning/ROADMAP.md
@.planning/phases/08-plugin-system-gateway/08-CONTEXT.md
@.planning/phases/08-plugin-system-gateway/08-RESEARCH.md

<interfaces>
<!-- Key types from existing codebase that the gateway must implement -->

From crates/blufio-core/src/traits/channel.rs:
```rust
#[async_trait]
pub trait ChannelAdapter: PluginAdapter {
    fn capabilities(&self) -> ChannelCapabilities;
    async fn connect(&mut self) -> Result<(), BlufioError>;
    async fn send(&self, msg: OutboundMessage) -> Result<MessageId, BlufioError>;
    async fn receive(&self) -> Result<InboundMessage, BlufioError>;
    async fn edit_message(&self, _chat_id: &str, _message_id: &str, _text: &str, _parse_mode: Option<&str>) -> Result<(), BlufioError> { Ok(()) }
    async fn send_typing(&self, _chat_id: &str) -> Result<(), BlufioError> { Ok(()) }
}
```

From crates/blufio-core/src/traits/adapter.rs:
```rust
#[async_trait]
pub trait PluginAdapter: Send + Sync + 'static {
    fn name(&self) -> &str;
    fn version(&self) -> semver::Version;
    fn adapter_type(&self) -> AdapterType;
    async fn health_check(&self) -> Result<HealthStatus, BlufioError>;
    async fn shutdown(&self) -> Result<(), BlufioError>;
}
```

From crates/blufio-core/src/types.rs:
```rust
pub struct InboundMessage {
    pub id: String,
    pub session_id: Option<String>,
    pub channel: String,
    pub sender_id: String,
    pub content: MessageContent,
    pub timestamp: String,
    pub metadata: Option<String>,
}

pub struct OutboundMessage {
    pub session_id: Option<String>,
    pub channel: String,
    pub content: String,
    pub reply_to: Option<String>,
    pub parse_mode: Option<String>,
    pub metadata: Option<String>,
}

pub struct MessageId(pub String);

pub struct ChannelCapabilities {
    pub supports_edit: bool,
    pub supports_typing: bool,
    pub supports_images: bool,
    pub supports_documents: bool,
    pub supports_voice: bool,
    pub max_message_length: Option<usize>,
}

pub enum MessageContent {
    Text(String),
    Image { data: Vec<u8>, mime_type: String, caption: Option<String> },
    Document { data: Vec<u8>, filename: String, mime_type: String },
    Voice { data: Vec<u8>, duration_secs: Option<f32> },
}

pub enum HealthStatus {
    Healthy,
    Degraded(String),
    Unhealthy(String),
}
```
</interfaces>
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create blufio-gateway crate with GatewayChannel (ChannelAdapter) and axum server</name>
  <files>Cargo.toml, crates/blufio-gateway/Cargo.toml, crates/blufio-gateway/src/lib.rs, crates/blufio-gateway/src/server.rs, crates/blufio-gateway/src/auth.rs, crates/blufio-config/src/model.rs</files>
  <action>
1. Add workspace dependencies to root `Cargo.toml`:
   ```toml
   axum = { version = "0.8", features = ["ws"] }
   axum-extra = { version = "0.10", features = ["typed-header"] }
   tower-http = { version = "0.6", features = ["cors", "trace"] }
   dashmap = "6"
   ```

2. Add `blufio-gateway` to workspace members in root Cargo.toml.

3. Create `crates/blufio-gateway/Cargo.toml`:
   - Dependencies: blufio-core (path), async-trait (workspace), axum (workspace), axum-extra (workspace), tower-http (workspace), tokio (workspace, features = ["sync", "net", "macros"]), serde (workspace), serde_json = "1", uuid (workspace), chrono (workspace), tracing (workspace), semver (workspace), dashmap (workspace), futures = "0.3"
   - Dev-dependencies: tokio = { workspace = true, features = ["test-util", "macros", "rt-multi-thread"] }, reqwest = { workspace = true }

4. Add `GatewayConfig` to `crates/blufio-config/src/model.rs`:
   ```rust
   /// HTTP/WebSocket gateway configuration.
   ///
   /// Controls the API gateway server for programmatic access alongside
   /// channel-based messaging (e.g., Telegram).
   #[derive(Debug, Clone, Deserialize, Serialize)]
   #[serde(deny_unknown_fields)]
   pub struct GatewayConfig {
       /// Enable the HTTP/WebSocket gateway.
       #[serde(default = "default_gateway_enabled")]
       pub enabled: bool,
       /// Host address to bind the gateway server.
       #[serde(default = "default_gateway_host")]
       pub host: String,
       /// Port for the gateway server.
       #[serde(default = "default_gateway_port")]
       pub port: u16,
       /// Bearer token for API authentication. If empty, auth is disabled.
       #[serde(default)]
       pub bearer_token: Option<String>,
   }
   ```
   - Add defaults: enabled = false, host = "127.0.0.1", port = 3000
   - Add `impl Default for GatewayConfig`
   - Add `#[serde(default)] pub gateway: GatewayConfig` to `BlufioConfig`

5. Create `crates/blufio-gateway/src/auth.rs`:
   - Bearer token extraction and validation middleware:
     ```rust
     use axum::{
         extract::Request,
         http::StatusCode,
         middleware::Next,
         response::Response,
     };

     #[derive(Clone)]
     pub struct AuthConfig {
         pub bearer_token: Option<String>,
     }

     pub async fn auth_middleware(
         axum::extract::State(auth): axum::extract::State<AuthConfig>,
         request: Request,
         next: Next,
     ) -> Result<Response, StatusCode> {
         // If no bearer_token configured, allow all requests (auth disabled)
         let Some(ref expected_token) = auth.bearer_token else {
             return Ok(next.run(request).await);
         };

         // Extract Authorization header
         let auth_header = request.headers()
             .get("authorization")
             .and_then(|v| v.to_str().ok())
             .and_then(|v| v.strip_prefix("Bearer "));

         match auth_header {
             Some(token) if token == expected_token => Ok(next.run(request).await),
             _ => Err(StatusCode::UNAUTHORIZED),
         }
     }
     ```

6. Create `crates/blufio-gateway/src/server.rs`:
   - `GatewayState` struct (shared state for axum handlers):
     ```rust
     #[derive(Clone)]
     pub struct GatewayState {
         pub inbound_tx: mpsc::Sender<InboundMessage>,
         pub response_map: Arc<DashMap<String, oneshot::Sender<String>>>,
         pub ws_senders: Arc<DashMap<String, mpsc::Sender<String>>>,
         pub auth: AuthConfig,
     }
     ```
   - `pub async fn start_server(config: &GatewayConfig, state: GatewayState) -> Result<(), BlufioError>`:
     - Build axum Router with routes:
       - POST /v1/messages -> handlers::post_messages
       - GET /v1/sessions -> handlers::get_sessions
       - GET /v1/health -> handlers::get_health
       - GET /ws -> ws::ws_handler
     - Apply auth_middleware to /v1/* routes (not /ws -- ws auth happens during handshake)
     - Apply CORS layer from tower-http (allow all origins for local dev, configurable later)
     - Bind to config.host:config.port
     - Run axum::serve with graceful shutdown support

7. Create `crates/blufio-gateway/src/lib.rs`:
   - `pub mod server;`
   - `pub mod handlers;`
   - `pub mod ws;`
   - `pub mod sse;`
   - `pub mod auth;`

   - `GatewayChannel` struct implementing ChannelAdapter:
     ```rust
     pub struct GatewayChannel {
         config: GatewayConfig,
         inbound_tx: mpsc::Sender<InboundMessage>,
         inbound_rx: tokio::sync::Mutex<mpsc::Receiver<InboundMessage>>,
         response_map: Arc<DashMap<String, oneshot::Sender<String>>>,
         ws_senders: Arc<DashMap<String, mpsc::Sender<String>>>,
         server_handle: tokio::sync::Mutex<Option<tokio::task::JoinHandle<()>>>,
     }
     ```
   - Constructor: `pub fn new(config: GatewayConfig) -> Self`
     - Creates mpsc channel (buffer 256) for inbound messages
     - Creates DashMap for response routing
     - Creates DashMap for WebSocket sender tracking
   - `PluginAdapter` impl:
     - name: "gateway"
     - version: 0.1.0
     - adapter_type: Channel
     - health_check: returns Healthy if server_handle is Some
     - shutdown: aborts server handle
   - `ChannelAdapter` impl:
     - capabilities: supports_edit = false, supports_typing = false (SSE/WS stream instead), supports_images = false, supports_documents = false, supports_voice = false, max_message_length = None
     - connect: spawns the axum server as a background tokio task, stores JoinHandle
     - receive: awaits on inbound_rx
     - send: Looks up OutboundMessage by extracting request_id from metadata. If found in response_map, sends via oneshot. If found in ws_senders, sends via mpsc. Returns MessageId.
     - edit_message: no-op (API doesn't support edit)
     - send_typing: for WebSocket connections, sends a {"type": "typing"} message via ws_senders

8. Tests:
   - GatewayChannel::new creates without error
   - GatewayConfig defaults: enabled = false, host = "127.0.0.1", port = 3000
   - AuthConfig with None bearer_token allows requests (test auth_middleware directly is possible with axum test utils, but basic unit test of logic suffices)
   - ChannelCapabilities has supports_edit = false
   - GatewayChannel name returns "gateway"
   - GatewayChannel adapter_type returns Channel
  </action>
  <verify>cd /Users/suman/projects/github/blufio && cargo test -p blufio-gateway && cargo check -p blufio-gateway</verify>
  <done>GatewayChannel implements ChannelAdapter, axum server structure defined, auth middleware ready, GatewayConfig in BlufioConfig</done>
</task>

<task type="auto">
  <name>Task 2: Implement REST API handlers, SSE streaming, and WebSocket handler</name>
  <files>crates/blufio-gateway/src/handlers.rs, crates/blufio-gateway/src/sse.rs, crates/blufio-gateway/src/ws.rs</files>
  <action>
1. Create `crates/blufio-gateway/src/handlers.rs`:
   - Define request/response types:
     ```rust
     #[derive(Debug, Deserialize)]
     pub struct MessageRequest {
         pub content: String,
         #[serde(default)]
         pub session_id: Option<String>,
         #[serde(default)]
         pub sender_id: Option<String>,
     }

     #[derive(Debug, Serialize)]
     pub struct MessageResponse {
         pub id: String,
         pub content: String,
         pub session_id: Option<String>,
         pub created_at: String,
     }

     #[derive(Debug, Serialize)]
     pub struct HealthResponse {
         pub status: String,
         pub version: String,
         pub uptime_secs: u64,
     }

     #[derive(Debug, Serialize)]
     pub struct SessionListResponse {
         pub sessions: Vec<SessionInfo>,
     }

     #[derive(Debug, Serialize)]
     pub struct SessionInfo {
         pub id: String,
         pub channel: String,
         pub state: String,
         pub created_at: String,
     }

     #[derive(Debug, Serialize)]
     pub struct ErrorResponse {
         pub error: String,
     }
     ```

   - `pub async fn post_messages(State(state): State<GatewayState>, headers: HeaderMap, Json(body): Json<MessageRequest>) -> Response`:
     - Check Accept header for "text/event-stream" -- if present, route to SSE handler
     - Generate request_id (UUID)
     - Create InboundMessage:
       - id: request_id
       - session_id: body.session_id
       - channel: "api"
       - sender_id: body.sender_id.unwrap_or("api-user")
       - content: MessageContent::Text(body.content)
       - timestamp: now
       - metadata: Some(json!({"request_id": request_id, "channel": "api"}).to_string())
     - Create oneshot channel, insert sender into response_map keyed by request_id
     - Send InboundMessage to inbound_tx (with timeout 5s, return 503 if full)
     - Await oneshot receiver (with timeout 120s for LLM response, return 504 if timeout)
     - Return 200 with MessageResponse JSON
     - On error, return appropriate HTTP status with ErrorResponse

   - `pub async fn get_health(State(state): State<GatewayState>) -> Json<HealthResponse>`:
     - Return status "ok", version from env!("CARGO_PKG_VERSION"), uptime placeholder (0 for now)

   - `pub async fn get_sessions(State(state): State<GatewayState>) -> Json<SessionListResponse>`:
     - Note: This handler needs access to StorageAdapter which is not in GatewayState.
     - For now, return empty sessions list. Plan 03 will wire storage into gateway state.
     - Add a TODO comment: "Wire StorageAdapter into GatewayState in Plan 03 integration"

2. Create `crates/blufio-gateway/src/sse.rs`:
   - SSE streaming for POST /v1/messages with Accept: text/event-stream:
     ```rust
     use axum::response::sse::{Event, Sse};
     use futures::stream::Stream;

     pub async fn stream_messages(
         state: GatewayState,
         body: MessageRequest,
     ) -> Sse<impl Stream<Item = Result<Event, std::convert::Infallible>>> {
         // Generate request_id
         // Create mpsc channel for streaming chunks
         // Store sender in state (use a separate streaming_map for SSE)
         // Create InboundMessage with metadata indicating SSE mode
         // Send to inbound_tx
         // Return Sse stream that reads from mpsc receiver
         // Each chunk becomes an SSE event: data: {"type": "text_delta", "text": "..."}
         // Final event: data: {"type": "message_stop"}
     }
     ```
   - SSE event format:
     ```
     event: text_delta
     data: {"text": "partial content here"}

     event: message_stop
     data: {"content": "full content", "session_id": "..."}
     ```
   - Note: Full SSE streaming requires integration with the agent loop's streaming response. For now, implement the SSE infrastructure and have it return the complete response as a single text_delta + message_stop. Plan 03 will wire true streaming.

3. Create `crates/blufio-gateway/src/ws.rs`:
   - WebSocket handler:
     ```rust
     use axum::extract::ws::{Message, WebSocket, WebSocketUpgrade};

     pub async fn ws_handler(
         ws: WebSocketUpgrade,
         State(state): State<GatewayState>,
     ) -> Response {
         ws.on_upgrade(|socket| handle_socket(socket, state))
     }

     async fn handle_socket(socket: WebSocket, state: GatewayState) {
         let (mut ws_sender, mut ws_receiver) = socket.split();
         let ws_id = uuid::Uuid::new_v4().to_string();

         // Create mpsc channel for sending responses back to this WebSocket
         let (tx, mut rx) = mpsc::channel::<String>(64);
         state.ws_senders.insert(ws_id.clone(), tx);

         // Spawn task to forward responses to WebSocket
         let sender_task = tokio::spawn(async move {
             while let Some(msg) = rx.recv().await {
                 if ws_sender.send(Message::Text(msg.into())).await.is_err() {
                     break;
                 }
             }
         });

         // Read messages from WebSocket client
         while let Some(Ok(msg)) = ws_receiver.next().await {
             match msg {
                 Message::Text(text) => {
                     // Parse JSON: {"content": "...", "session_id": "..."}
                     // Create InboundMessage with channel = "ws"
                     // metadata includes ws_id for response routing
                     // Send to inbound_tx
                 }
                 Message::Close(_) => break,
                 _ => {} // Ignore binary, ping (handled by tungstenite)
             }
         }

         // Cleanup
         state.ws_senders.remove(&ws_id);
         sender_task.abort();
     }
     ```
   - WebSocket message format (client -> server):
     ```json
     {"content": "Hello, what's the weather?", "session_id": "optional-session-id"}
     ```
   - WebSocket message format (server -> client):
     ```json
     {"type": "typing"}
     {"type": "text_delta", "text": "partial..."}
     {"type": "message_complete", "content": "full response", "session_id": "..."}
     ```

4. Tests:
   - MessageRequest deserializes from JSON with content field
   - MessageRequest deserializes without optional session_id
   - HealthResponse serializes to JSON with status, version fields
   - ErrorResponse serializes correctly
   - WebSocket message format constants are correct
   - SSE event types are defined correctly
  </action>
  <verify>cd /Users/suman/projects/github/blufio && cargo test -p blufio-gateway && cargo check -p blufio-gateway</verify>
  <done>REST API handlers (POST /v1/messages, GET /v1/health, GET /v1/sessions), SSE streaming infrastructure, and WebSocket handler implemented with proper request/response types</done>
</task>

</tasks>

<verification>
1. `cargo test -p blufio-gateway` -- all handler, auth, and type tests pass
2. `cargo test -p blufio-config` -- GatewayConfig defaults work, deny_unknown_fields passes
3. `cargo check --workspace` -- entire workspace compiles with axum dependencies
4. `cargo clippy --workspace` -- no warnings
</verification>

<success_criteria>
- blufio-gateway crate exists with GatewayChannel implementing ChannelAdapter
- axum server starts in background task with /v1/messages, /v1/sessions, /v1/health, /ws, and /metrics routes
- POST /v1/messages creates InboundMessage and waits for response via oneshot channel
- SSE streaming infrastructure in place for Accept: text/event-stream
- WebSocket handler supports bidirectional JSON messaging
- Bearer token auth middleware validates Authorization header
- GatewayChannel::receive() reads from mpsc channel populated by axum handlers
- GatewayChannel::send() routes responses back to waiting HTTP/WebSocket clients
- GatewayConfig in BlufioConfig with host, port, bearer_token, enabled
- All tests pass, workspace compiles, no clippy warnings
</success_criteria>

<output>
After completion, create `.planning/phases/08-plugin-system-gateway/08-02-SUMMARY.md`
</output>
