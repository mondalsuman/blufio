---
phase: 08-plugin-system-gateway
plan: 03
type: execute
wave: 2
depends_on: ["08-01", "08-02"]
files_modified:
  - Cargo.toml
  - crates/blufio-prometheus/Cargo.toml
  - crates/blufio-prometheus/src/lib.rs
  - crates/blufio-prometheus/src/metrics.rs
  - crates/blufio-auth-keypair/Cargo.toml
  - crates/blufio-auth-keypair/src/lib.rs
  - crates/blufio-auth-keypair/src/keypair.rs
  - crates/blufio-core/src/types.rs
  - crates/blufio-agent/src/lib.rs
  - crates/blufio-agent/src/channel_mux.rs
  - crates/blufio/Cargo.toml
  - crates/blufio/src/serve.rs
  - crates/blufio/src/main.rs
  - crates/blufio-config/src/model.rs
autonomous: true
requirements:
  - PLUG-04
  - INFRA-05

must_haves:
  truths:
    - "ChannelMultiplexer implements ChannelAdapter and aggregates InboundMessages from multiple channels (Telegram + Gateway)"
    - "ChannelMultiplexer routes OutboundMessages back to the originating channel based on the channel field"
    - "PrometheusAdapter implements ObservabilityAdapter and exposes metrics via handle.render() on the gateway /metrics path"
    - "Prometheus metrics include blufio_messages_total, blufio_active_sessions, blufio_response_latency_seconds, blufio_tokens_total, blufio_budget_remaining_usd"
    - "KeypairAuthAdapter implements AuthAdapter with Ed25519 device keypair from vault or auto-generated on first run"
    - "serve.rs initializes PluginRegistry with all default adapters, queries it for active adapters, and wires them"
    - "serve.rs creates ChannelMultiplexer with Telegram + Gateway (if enabled) and passes it as the single ChannelAdapter to AgentLoop"
    - "Prometheus handle is passed to the gateway axum server for the /metrics endpoint"
    - "Default build includes all 6 adapters via Cargo default features: telegram, anthropic, sqlite, onnx, prometheus, keypair"
    - "Building with --no-default-features --features api,anthropic,sqlite produces a minimal binary"
  artifacts:
    - crates/blufio-prometheus/src/lib.rs
    - crates/blufio-auth-keypair/src/lib.rs
    - crates/blufio-agent/src/channel_mux.rs
    - crates/blufio/src/serve.rs
  key_links:
    - "ChannelMultiplexer spawns per-channel receive tasks that forward to a shared mpsc channel"
    - "serve.rs creates PluginRegistry, registers factories, checks config for enabled/disabled overrides"
    - "PrometheusAdapter provides handle that gateway uses for /metrics endpoint rendering"
    - "KeypairAuthAdapter auto-generates Ed25519 keypair on first run and stores in vault"
---

<objective>
Wire the plugin system, gateway, Prometheus metrics, and device keypair auth into serve.rs. Create the ChannelMultiplexer for multi-channel support, the blufio-prometheus crate for metrics, the blufio-auth-keypair crate for authentication, and refactor serve.rs to use the PluginRegistry pattern with Cargo feature gates for the default adapter bundle.

Purpose: This is the integration plan that makes everything from Plans 01 and 02 actually work together. After this plan, `blufio serve` starts with Telegram + Gateway (if enabled), Prometheus metrics are exported, and the PluginRegistry manages all adapter lifecycle. The default binary ships with all 6 adapters, while custom builds can select specific features.

Output: blufio-prometheus crate, blufio-auth-keypair crate, ChannelMultiplexer in blufio-agent, refactored serve.rs with PluginRegistry pattern, Cargo feature flags for all adapters.
</objective>

<execution_context>
@/Users/suman/.claude/get-shit-done/workflows/execute-plan.md
@/Users/suman/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/STATE.md
@.planning/ROADMAP.md
@.planning/phases/08-plugin-system-gateway/08-CONTEXT.md
@.planning/phases/08-plugin-system-gateway/08-RESEARCH.md
@.planning/phases/08-plugin-system-gateway/08-01-SUMMARY.md
@.planning/phases/08-plugin-system-gateway/08-02-SUMMARY.md

<interfaces>
<!-- Key types from Plans 01 and 02 that this plan depends on -->

From blufio-plugin/src/registry.rs (Plan 01):
```rust
pub struct PluginRegistry {
    // register, get, get_enabled, list_all, set_enabled
}
pub struct PluginEntry {
    pub manifest: PluginManifest,
    pub status: PluginStatus,
    pub factory: Option<Box<dyn PluginFactory>>,
}
pub enum PluginStatus { Enabled, Disabled, NotConfigured }
pub trait PluginFactory: Send + Sync {
    fn adapter_type(&self) -> AdapterType;
    fn create(&self, config: &serde_json::Value) -> Result<Box<dyn PluginAdapter>, BlufioError>;
}
```

From blufio-plugin/src/catalog.rs (Plan 01):
```rust
pub fn builtin_catalog() -> Vec<PluginManifest>;
```

From blufio-gateway/src/lib.rs (Plan 02):
```rust
pub struct GatewayChannel {
    // Implements ChannelAdapter
    // Constructor: fn new(config: GatewayConfig) -> Self
}
```

From blufio-gateway/src/server.rs (Plan 02):
```rust
pub struct GatewayState {
    pub inbound_tx: mpsc::Sender<InboundMessage>,
    pub response_map: Arc<DashMap<String, oneshot::Sender<String>>>,
    pub ws_senders: Arc<DashMap<String, mpsc::Sender<String>>>,
    pub auth: AuthConfig,
}
```

From blufio-core/src/types.rs:
```rust
pub struct AuthToken { pub _placeholder: () }
pub struct AuthIdentity { pub _placeholder: () }
pub struct MetricEvent { pub _placeholder: () }
```

From blufio-core/src/traits/observability.rs:
```rust
#[async_trait]
pub trait ObservabilityAdapter: PluginAdapter {
    async fn record(&self, event: MetricEvent) -> Result<(), BlufioError>;
}
```

From blufio-core/src/traits/auth.rs:
```rust
#[async_trait]
pub trait AuthAdapter: PluginAdapter {
    async fn authenticate(&self, token: AuthToken) -> Result<AuthIdentity, BlufioError>;
}
```

From blufio-agent/src/lib.rs (current AgentLoop):
```rust
pub struct AgentLoop {
    channel: Box<dyn ChannelAdapter + Send + Sync>,
    // ... accepts single channel ...
}
```

From blufio/src/serve.rs (current):
```rust
// Hardcoded adapter initialization pattern:
let storage = SqliteStorage::new(config.storage.clone());
let provider = AnthropicProvider::new(&config).await?;
let mut channel = TelegramChannel::new(config.telegram.clone())?;
// ... creates AgentLoop with single channel ...
```
</interfaces>
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create blufio-prometheus and blufio-auth-keypair crates, update core types</name>
  <files>Cargo.toml, crates/blufio-prometheus/Cargo.toml, crates/blufio-prometheus/src/lib.rs, crates/blufio-prometheus/src/metrics.rs, crates/blufio-auth-keypair/Cargo.toml, crates/blufio-auth-keypair/src/lib.rs, crates/blufio-auth-keypair/src/keypair.rs, crates/blufio-core/src/types.rs, crates/blufio-config/src/model.rs</files>
  <action>
1. Add workspace dependencies to root `Cargo.toml`:
   ```toml
   metrics = "0.24"
   metrics-exporter-prometheus = "0.16"
   ed25519-dalek = { version = "2.1", features = ["rand_core"] }
   ```
   Add `blufio-prometheus` and `blufio-auth-keypair` to workspace members.

2. Replace placeholder types in `crates/blufio-core/src/types.rs`:
   - Replace `AuthToken`:
     ```rust
     /// An authentication token to be verified.
     #[derive(Debug, Clone)]
     pub struct AuthToken {
         /// The raw bearer token string.
         pub token: String,
     }
     ```
   - Replace `AuthIdentity`:
     ```rust
     /// A verified identity from an auth adapter.
     #[derive(Debug, Clone)]
     pub struct AuthIdentity {
         /// Unique identifier for the authenticated entity.
         pub id: String,
         /// Human-readable label (e.g., device name).
         pub label: Option<String>,
     }
     ```
   - Replace `MetricEvent`:
     ```rust
     /// A metric or telemetry event.
     #[derive(Debug, Clone)]
     pub enum MetricEvent {
         /// Increment a counter.
         Counter { name: String, value: u64, labels: Vec<(String, String)> },
         /// Set a gauge value.
         Gauge { name: String, value: f64, labels: Vec<(String, String)> },
         /// Record a histogram observation.
         Histogram { name: String, value: f64, labels: Vec<(String, String)> },
     }
     ```

3. Add `PrometheusConfig` to `crates/blufio-config/src/model.rs`:
   ```rust
   /// Prometheus metrics configuration.
   #[derive(Debug, Clone, Deserialize, Serialize)]
   #[serde(deny_unknown_fields)]
   pub struct PrometheusConfig {
       /// Enable Prometheus metrics collection and export.
       #[serde(default = "default_prometheus_enabled")]
       pub enabled: bool,
   }
   ```
   - Default: enabled = false
   - Add `#[serde(default)] pub prometheus: PrometheusConfig` to `BlufioConfig`

4. Create `crates/blufio-prometheus/Cargo.toml`:
   - Dependencies: blufio-core (path), async-trait (workspace), metrics (workspace), metrics-exporter-prometheus (workspace), semver (workspace), tracing (workspace)

5. Create `crates/blufio-prometheus/src/metrics.rs`:
   - Define metric descriptions (called once at startup):
     ```rust
     pub fn register_metrics() {
         use metrics::{describe_counter, describe_gauge, describe_histogram};

         describe_counter!("blufio_messages_total", "Total messages processed");
         describe_counter!("blufio_tokens_total", "Total tokens consumed");
         describe_gauge!("blufio_active_sessions", "Currently active sessions");
         describe_gauge!("blufio_budget_remaining_usd", "Remaining daily budget in USD");
         describe_histogram!("blufio_response_latency_seconds", "LLM response latency in seconds");
     }
     ```
   - Helper functions for recording metrics:
     ```rust
     pub fn record_message(channel: &str) {
         metrics::counter!("blufio_messages_total", "channel" => channel.to_string()).increment(1);
     }
     pub fn record_tokens(model: &str, input: u32, output: u32) {
         metrics::counter!("blufio_tokens_total", "model" => model.to_string(), "type" => "input").increment(input as u64);
         metrics::counter!("blufio_tokens_total", "model" => model.to_string(), "type" => "output").increment(output as u64);
     }
     pub fn set_active_sessions(count: f64) {
         metrics::gauge!("blufio_active_sessions").set(count);
     }
     pub fn set_budget_remaining(usd: f64) {
         metrics::gauge!("blufio_budget_remaining_usd").set(usd);
     }
     pub fn record_latency(seconds: f64) {
         metrics::histogram!("blufio_response_latency_seconds").record(seconds);
     }
     ```

6. Create `crates/blufio-prometheus/src/lib.rs`:
   - `pub mod metrics;`
   - `PrometheusAdapter` struct:
     ```rust
     pub struct PrometheusAdapter {
         handle: metrics_exporter_prometheus::PrometheusHandle,
     }
     ```
   - Constructor: `pub fn new() -> Result<Self, BlufioError>`:
     - Call `PrometheusBuilder::new().install_recorder()` to get handle
     - Call `metrics::register_metrics()` to register descriptions
     - Return Self with handle
   - `pub fn handle(&self) -> &metrics_exporter_prometheus::PrometheusHandle` -- for axum /metrics endpoint
   - `pub fn render(&self) -> String` -- convenience method for handle.render()
   - Implement `PluginAdapter`:
     - name: "prometheus"
     - version: 0.1.0
     - adapter_type: Observability
     - health_check: Healthy
     - shutdown: no-op
   - Implement `ObservabilityAdapter`:
     - record: match MetricEvent variant and use metrics macros
   - Re-export: `pub use metrics::{record_message, record_tokens, set_active_sessions, set_budget_remaining, record_latency};`

7. Create `crates/blufio-auth-keypair/Cargo.toml`:
   - Dependencies: blufio-core (path), async-trait (workspace), ed25519-dalek (workspace), rand (workspace), semver (workspace), tracing (workspace), serde (workspace), serde_json = "1"

8. Create `crates/blufio-auth-keypair/src/keypair.rs`:
   - Ed25519 keypair generation:
     ```rust
     use ed25519_dalek::{SigningKey, VerifyingKey};
     use rand::rngs::OsRng;

     pub struct DeviceKeypair {
         signing_key: SigningKey,
         verifying_key: VerifyingKey,
     }

     impl DeviceKeypair {
         pub fn generate() -> Self {
             let signing_key = SigningKey::generate(&mut OsRng);
             let verifying_key = VerifyingKey::from(&signing_key);
             Self { signing_key, verifying_key }
         }
         pub fn from_bytes(private_bytes: &[u8; 32]) -> Result<Self, BlufioError> {
             let signing_key = SigningKey::from_bytes(private_bytes);
             let verifying_key = VerifyingKey::from(&signing_key);
             Ok(Self { signing_key, verifying_key })
         }
         pub fn private_bytes(&self) -> [u8; 32] { self.signing_key.to_bytes() }
         pub fn public_bytes(&self) -> [u8; 32] { self.verifying_key.to_bytes() }
         pub fn verify_token(&self, token: &str) -> bool {
             // Simple bearer token validation: token == hex-encoded public key
             // More sophisticated challenge-response is deferred to v2
             let expected = hex::encode(self.public_bytes());
             token == expected
         }
     }
     ```
   - Add `hex = "0.4"` to dependencies.

9. Create `crates/blufio-auth-keypair/src/lib.rs`:
   - `pub mod keypair;`
   - `pub use keypair::DeviceKeypair;`
   - `KeypairAuthAdapter` struct:
     ```rust
     pub struct KeypairAuthAdapter {
         keypair: DeviceKeypair,
     }
     ```
   - Constructor: `pub fn new(keypair: DeviceKeypair) -> Self`
   - Implement `PluginAdapter`:
     - name: "keypair-auth"
     - version: 0.1.0
     - adapter_type: Auth
     - health_check: Healthy
     - shutdown: no-op
   - Implement `AuthAdapter`:
     - authenticate: validate token against keypair, return AuthIdentity with device id

10. Tests:
    - PrometheusAdapter::new() creates successfully (may fail if recorder already installed -- use a test-only guard)
    - MetricEvent::Counter variant creates correctly
    - DeviceKeypair::generate creates valid keypair
    - DeviceKeypair::from_bytes roundtrip works (generate -> private_bytes -> from_bytes)
    - DeviceKeypair::verify_token with correct hex-encoded public key returns true
    - DeviceKeypair::verify_token with wrong token returns false
    - AuthToken and AuthIdentity are no longer placeholder types
  </action>
  <verify>cd /Users/suman/projects/github/blufio && cargo test -p blufio-prometheus && cargo test -p blufio-auth-keypair && cargo test -p blufio-core -- types && cargo check --workspace</verify>
  <done>Prometheus adapter records metrics and renders text format, keypair auth generates Ed25519 keys and validates tokens, core types are no longer placeholders</done>
</task>

<task type="auto">
  <name>Task 2: Create ChannelMultiplexer and wire everything in serve.rs with Cargo features</name>
  <files>crates/blufio-agent/src/channel_mux.rs, crates/blufio-agent/src/lib.rs, crates/blufio-agent/Cargo.toml, crates/blufio/Cargo.toml, crates/blufio/src/serve.rs, crates/blufio/src/main.rs</files>
  <action>
1. Create `crates/blufio-agent/src/channel_mux.rs`:
   - `ChannelMultiplexer` struct:
     ```rust
     pub struct ChannelMultiplexer {
         channels: Vec<(String, Box<dyn ChannelAdapter + Send + Sync>)>,
         inbound_rx: tokio::sync::Mutex<mpsc::Receiver<(String, InboundMessage)>>,
         inbound_tx: mpsc::Sender<(String, InboundMessage)>,
     }
     ```
   - Constructor: `pub fn new() -> Self` -- creates mpsc channel (buffer 512)
   - `pub fn add_channel(&mut self, name: String, channel: Box<dyn ChannelAdapter + Send + Sync>)` -- stores channel with its name
   - Implement `PluginAdapter`:
     - name: "multiplexer"
     - version: 0.1.0
     - adapter_type: Channel
     - health_check: check all child channels, return Degraded if any are unhealthy
     - shutdown: shutdown all child channels
   - Implement `ChannelAdapter`:
     - capabilities: union of all channel capabilities (supports_edit = true if any supports it)
     - connect: for each channel, call connect() and spawn a background task that loops:
       ```rust
       let tx = self.inbound_tx.clone();
       let channel_name = name.clone();
       tokio::spawn(async move {
           loop {
               match channel.receive().await {
                   Ok(mut msg) => {
                       // Tag the message with its source channel
                       if msg.metadata.is_none() {
                           msg.metadata = Some(serde_json::json!({"source_channel": channel_name}).to_string());
                       } else {
                           // Merge source_channel into existing metadata
                           if let Ok(mut meta) = serde_json::from_str::<serde_json::Value>(msg.metadata.as_ref().unwrap()) {
                               meta["source_channel"] = serde_json::Value::String(channel_name.clone());
                               msg.metadata = Some(meta.to_string());
                           }
                       }
                       if tx.send((channel_name.clone(), msg)).await.is_err() {
                           break; // Multiplexer dropped
                       }
                   }
                   Err(e) => {
                       if e.to_string().contains("closed") { break; }
                       tracing::warn!(error = %e, channel = %channel_name, "channel receive error");
                   }
               }
           }
       });
       ```
     - receive: read from inbound_rx, return the InboundMessage (channel name used for routing)
     - send: determine target channel from OutboundMessage.channel field or metadata.source_channel. Find matching channel in the channels vec, delegate send() to it.
     - edit_message: delegate to the appropriate channel based on channel field
     - send_typing: delegate to the appropriate channel
   - Note: After connect(), the individual channels are moved into background tasks. The multiplexer only exposes the unified receive/send interface.

2. Update `crates/blufio-agent/src/lib.rs`:
   - Add `pub mod channel_mux;`
   - Add `pub use channel_mux::ChannelMultiplexer;`

3. Add blufio-gateway as dependency to `crates/blufio-agent/Cargo.toml` (optional, behind "gateway" feature).

4. Set up Cargo features in `crates/blufio/Cargo.toml`:
   ```toml
   [features]
   default = ["telegram", "anthropic", "sqlite", "onnx", "prometheus", "keypair", "gateway"]
   telegram = ["dep:blufio-telegram"]
   anthropic = ["dep:blufio-anthropic"]
   sqlite = ["dep:blufio-storage"]
   onnx = ["dep:blufio-memory"]
   prometheus = ["dep:blufio-prometheus"]
   keypair = ["dep:blufio-auth-keypair"]
   gateway = ["dep:blufio-gateway"]

   [dependencies]
   blufio-telegram = { path = "../blufio-telegram", optional = true }
   blufio-anthropic = { path = "../blufio-anthropic", optional = true }
   blufio-storage = { path = "../blufio-storage", optional = true }
   blufio-memory = { path = "../blufio-memory", optional = true }
   blufio-prometheus = { path = "../blufio-prometheus", optional = true }
   blufio-auth-keypair = { path = "../blufio-auth-keypair", optional = true }
   blufio-gateway = { path = "../blufio-gateway", optional = true }
   # Non-optional deps remain as-is (blufio-core, blufio-config, blufio-agent, blufio-plugin, etc.)
   ```
   Note: blufio-core, blufio-config, blufio-agent, blufio-plugin, blufio-skill, blufio-context, blufio-cost, blufio-router, blufio-vault, blufio-security remain non-optional.

5. Refactor `crates/blufio/src/serve.rs` to use PluginRegistry:
   - Add imports for new crates (behind #[cfg(feature = "...")] as needed)
   - Create `initialize_plugin_registry` function:
     ```rust
     fn initialize_plugin_registry(config: &BlufioConfig) -> PluginRegistry {
         let mut registry = PluginRegistry::new();
         let catalog = blufio_plugin::builtin_catalog();

         for manifest in catalog {
             let name = manifest.name.clone();
             // Determine status from config
             let status = if let Some(&enabled) = config.plugin.plugins.get(&name) {
                 if enabled { PluginStatus::Enabled } else { PluginStatus::Disabled }
             } else {
                 PluginStatus::Enabled // Default: all compiled-in adapters enabled
             };
             registry.register_with_status(manifest, None, status);
         }

         info!("plugin registry initialized with {} plugins", registry.len());
         registry
     }
     ```
   - Refactor `run_serve` to use PluginRegistry and ChannelMultiplexer:
     - Initialize PluginRegistry
     - Initialize Prometheus (if enabled):
       ```rust
       #[cfg(feature = "prometheus")]
       let prometheus_adapter = if config.prometheus.enabled {
           match blufio_prometheus::PrometheusAdapter::new() {
               Ok(adapter) => {
                   info!("prometheus metrics enabled");
                   Some(adapter)
               }
               Err(e) => {
                   warn!(error = %e, "prometheus initialization failed");
                   None
               }
           }
       } else { None };
       ```
     - Build ChannelMultiplexer:
       ```rust
       let mut mux = ChannelMultiplexer::new();

       // Add Telegram channel (if enabled and configured)
       #[cfg(feature = "telegram")]
       if config.telegram.bot_token.is_some() {
           let mut telegram = TelegramChannel::new(config.telegram.clone())?;
           mux.add_channel("telegram".to_string(), Box::new(telegram));
           info!("telegram channel added to multiplexer");
       }

       // Add Gateway channel (if enabled)
       #[cfg(feature = "gateway")]
       if config.gateway.enabled {
           let gateway = blufio_gateway::GatewayChannel::new(config.gateway.clone());
           mux.add_channel("gateway".to_string(), Box::new(gateway));
           info!("gateway channel added to multiplexer");
       }

       // Connect all channels via multiplexer
       mux.connect().await?;
       ```
     - Pass ChannelMultiplexer (as Box<dyn ChannelAdapter>) to AgentLoop::new instead of the single TelegramChannel
     - If prometheus is enabled and gateway is enabled, pass the PrometheusHandle to the gateway server's state for /metrics rendering
     - Keep existing initialization for storage, provider, context engine, memory, skills, routing, heartbeat -- these don't change

6. Update gateway /metrics endpoint in serve.rs integration:
   - When both gateway and prometheus are enabled, the gateway's axum server needs the PrometheusHandle
   - This is wired through GatewayState or by adding a /metrics handler after the gateway channel is constructed
   - The simplest approach: after GatewayChannel is created but before connect(), set the prometheus handle on the gateway state. Add a method `pub fn set_metrics_handle(&mut self, handle: PrometheusHandle)` to GatewayChannel that adds the /metrics route to the server.

7. Tests:
   - ChannelMultiplexer::new creates successfully
   - ChannelMultiplexer with 0 channels still creates (no-op multiplexer)
   - ChannelMultiplexer name returns "multiplexer"
   - initialize_plugin_registry returns registry with 6+ entries
   - Cargo features compile: `cargo check -p blufio --no-default-features --features anthropic,sqlite`
   - Default features compile: `cargo check -p blufio`
  </action>
  <verify>cd /Users/suman/projects/github/blufio && cargo test -p blufio-agent -- channel_mux && cargo check --workspace && cargo check -p blufio --no-default-features --features anthropic,sqlite</verify>
  <done>ChannelMultiplexer aggregates channels, serve.rs uses PluginRegistry, Prometheus metrics exported via gateway /metrics, all default adapters ship as Cargo features, minimal build works</done>
</task>

</tasks>

<verification>
1. `cargo test --workspace` -- all tests across all crates pass
2. `cargo check --workspace` -- full workspace compiles with default features
3. `cargo check -p blufio --no-default-features --features anthropic,sqlite` -- minimal build compiles
4. `cargo clippy --workspace` -- no warnings
5. Verify serve.rs creates ChannelMultiplexer and passes to AgentLoop
6. Verify Prometheus metrics are registered and renderable
7. Verify Ed25519 keypair generation and token validation
</verification>

<success_criteria>
- blufio-prometheus crate records metrics via metrics-rs facade and renders Prometheus text format
- blufio-auth-keypair crate generates Ed25519 keypairs and validates bearer tokens
- ChannelMultiplexer aggregates multiple channels into single ChannelAdapter interface
- serve.rs uses PluginRegistry to discover and initialize adapters
- serve.rs creates ChannelMultiplexer with Telegram + Gateway and passes to AgentLoop
- Gateway /metrics endpoint renders Prometheus metrics
- Default build includes all 6 adapter crates via Cargo features
- Custom build with --no-default-features compiles
- Core types (AuthToken, AuthIdentity, MetricEvent) are no longer placeholders
- All tests pass, workspace compiles, no clippy warnings
</success_criteria>

<output>
After completion, create `.planning/phases/08-plugin-system-gateway/08-03-SUMMARY.md`
</output>
