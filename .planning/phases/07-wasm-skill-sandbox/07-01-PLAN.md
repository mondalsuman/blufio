---
phase: 07-wasm-skill-sandbox
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - Cargo.toml
  - crates/blufio-skill/Cargo.toml
  - crates/blufio-skill/src/lib.rs
  - crates/blufio-skill/src/tool.rs
  - crates/blufio-skill/src/builtin/mod.rs
  - crates/blufio-skill/src/builtin/bash.rs
  - crates/blufio-skill/src/builtin/http.rs
  - crates/blufio-skill/src/builtin/file.rs
  - crates/blufio-core/src/types.rs
  - crates/blufio-core/src/error.rs
  - crates/blufio-anthropic/src/types.rs
  - crates/blufio-anthropic/src/client.rs
  - crates/blufio-anthropic/src/sse.rs
autonomous: true
requirements:
  - SKILL-01

must_haves:
  truths:
    - "Tool trait defines name(), description(), parameters_schema(), invoke() methods and ToolRegistry manages tool lookup by name"
    - "BashTool executes shell commands via tokio::process::Command and returns stdout/stderr as ToolOutput"
    - "HttpTool makes HTTP requests using reqwest with SSRF prevention from blufio-security and returns status + body"
    - "FileTool reads and writes files with path validation and returns file contents or write confirmation"
    - "Anthropic provider sends tools array in MessageRequest and handles tool_use content blocks in streaming responses"
    - "tool_use content blocks accumulate partial JSON via input_json_delta events and parse complete JSON on content_block_stop"
    - "ProviderStreamChunk includes ToolUse variant with tool_use_id, name, and input fields"
    - "BlufioError::Skill variant captures tool execution failures"
  artifacts:
    - crates/blufio-skill/src/tool.rs
    - crates/blufio-skill/src/builtin/bash.rs
    - crates/blufio-skill/src/builtin/http.rs
    - crates/blufio-skill/src/builtin/file.rs
    - crates/blufio-anthropic/src/types.rs
    - crates/blufio-anthropic/src/client.rs
  key_links:
    - "ToolRegistry::get(name) returns Arc<dyn Tool> for the agent loop to invoke"
    - "Anthropic types include ToolDefinition, ToolUseBlock, ToolResultBlock for API serialization"
    - "ProviderStreamChunk::ToolUse carries parsed tool invocation data from streamed response"
---

<objective>
Create the blufio-skill crate with the unified Tool trait, ToolRegistry, and three built-in tools (bash, HTTP, file I/O). Extend the Anthropic provider types and SSE parser to support tool_use/tool_result message flow.

Purpose: Establish the tool calling foundation that both built-in tools and WASM skills share. Without this, the agent cannot invoke any tools. The Anthropic provider must understand tool definitions and tool_use responses for the LLM to call tools.

Output: New blufio-skill crate with Tool trait + 3 built-in tools. Extended Anthropic types with tool_use/tool_result support. Extended ProviderStreamChunk with ToolUse variant. New BlufioError::Skill variant.
</objective>

<execution_context>
@/Users/suman/.claude/get-shit-done/workflows/execute-plan.md
@/Users/suman/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/STATE.md
@.planning/ROADMAP.md
@.planning/phases/07-wasm-skill-sandbox/07-CONTEXT.md
@.planning/phases/07-wasm-skill-sandbox/07-RESEARCH.md

<interfaces>
<!-- Key types and contracts the executor needs. Extracted from codebase. -->

From crates/blufio-core/src/error.rs:
```rust
#[derive(Debug, Error)]
pub enum BlufioError {
    #[error("configuration error: {0}")]
    Config(String),
    #[error("storage error: {source}")]
    Storage { source: Box<dyn std::error::Error + Send + Sync> },
    #[error("channel error: {message}")]
    Channel { message: String, source: Option<Box<dyn std::error::Error + Send + Sync>> },
    #[error("provider error: {message}")]
    Provider { message: String, source: Option<Box<dyn std::error::Error + Send + Sync>> },
    // ... other variants ...
    #[error("internal error: {0}")]
    Internal(String),
}
```

From crates/blufio-core/src/types.rs (stream events):
```rust
pub enum StreamEventType {
    MessageStart, ContentBlockStart, ContentBlockDelta,
    ContentBlockStop, MessageDelta, MessageStop, Ping, Error,
}

pub struct ProviderStreamChunk {
    pub event_type: StreamEventType,
    pub text: Option<String>,
    pub usage: Option<TokenUsage>,
    pub error: Option<String>,
}
```

From crates/blufio-anthropic/src/types.rs:
```rust
pub struct MessageRequest {
    pub model: String,
    pub messages: Vec<ApiMessage>,
    pub system: Option<SystemContent>,
    pub max_tokens: u32,
    pub stream: bool,
    pub cache_control: Option<CacheControlMarker>,
}

pub enum ApiContentBlock {
    #[serde(rename = "text")]
    Text { text: String },
    #[serde(rename = "image")]
    Image { source: ImageSource },
}

pub enum SseDelta {
    #[serde(rename = "text_delta")]
    TextDelta { text: String },
    #[serde(rename = "input_json_delta")]
    InputJsonDelta { partial_json: String },
}
```

From crates/blufio-security (existing):
- SSRF prevention (private IP blocking) and TLS enforcement available for HTTP tool
</interfaces>
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create blufio-skill crate with Tool trait and ToolRegistry</name>
  <files>Cargo.toml, crates/blufio-skill/Cargo.toml, crates/blufio-skill/src/lib.rs, crates/blufio-skill/src/tool.rs</files>
  <action>
1. Add `blufio-skill` to workspace members in root Cargo.toml.

2. Create `crates/blufio-skill/Cargo.toml`:
   - Dependencies: blufio-core (path), async-trait (workspace), serde (workspace), serde_json = "1", tokio (workspace, features = ["process", "fs"]), reqwest (workspace), tracing (workspace)
   - Dev-dependencies: tokio (features = ["test-util", "macros"])

3. Create `crates/blufio-skill/src/tool.rs`:
   - `ToolOutput` struct: `{ content: String, is_error: bool }`
   - `Tool` trait (async_trait, Send + Sync):
     - `fn name(&self) -> &str`
     - `fn description(&self) -> &str`
     - `fn parameters_schema(&self) -> serde_json::Value` (returns JSON Schema object for the tool's input)
     - `async fn invoke(&self, input: serde_json::Value) -> Result<ToolOutput, BlufioError>`
   - `ToolRegistry` struct with `HashMap<String, Arc<dyn Tool>>`:
     - `fn new() -> Self`
     - `fn register(&mut self, tool: Arc<dyn Tool>)` — registers tool by its name()
     - `fn get(&self, name: &str) -> Option<Arc<dyn Tool>>` — lookup by name
     - `fn list(&self) -> Vec<(&str, &str)>` — returns (name, description) pairs for all tools
     - `fn tool_definitions(&self) -> Vec<serde_json::Value>` — returns Anthropic-format tool definitions for all registered tools

4. Create `crates/blufio-skill/src/lib.rs`:
   - `pub mod tool;`
   - `pub mod builtin;`
   - Re-export: `pub use tool::{Tool, ToolOutput, ToolRegistry};`

5. Tests in tool.rs:
   - ToolRegistry registers and retrieves tools
   - ToolRegistry::list returns all registered tool names and descriptions
   - ToolRegistry::get returns None for unknown tools
   - ToolRegistry::tool_definitions produces valid JSON with name, description, input_schema fields
  </action>
  <verify>cd /Users/suman/projects/github/blufio && cargo test -p blufio-skill -- tool</verify>
  <done>Tool trait defined, ToolRegistry stores and retrieves tools, tool_definitions() returns Anthropic-format JSON</done>
</task>

<task type="auto">
  <name>Task 2: Implement BashTool, HttpTool, and FileTool built-in tools</name>
  <files>crates/blufio-skill/src/builtin/mod.rs, crates/blufio-skill/src/builtin/bash.rs, crates/blufio-skill/src/builtin/http.rs, crates/blufio-skill/src/builtin/file.rs</files>
  <action>
1. Create `crates/blufio-skill/src/builtin/mod.rs`:
   - `pub mod bash;`
   - `pub mod http;`
   - `pub mod file;`
   - `pub use bash::BashTool;`
   - `pub use http::HttpTool;`
   - `pub use file::FileTool;`
   - `pub fn register_builtins(registry: &mut ToolRegistry)` — creates and registers all 3 built-in tools

2. Create `crates/blufio-skill/src/builtin/bash.rs`:
   - `BashTool` struct (unit struct)
   - Implements Tool:
     - name: "bash"
     - description: "Execute a bash command and return stdout/stderr"
     - parameters_schema: `{ "type": "object", "properties": { "command": { "type": "string", "description": "The bash command to execute" } }, "required": ["command"] }`
     - invoke: Extract "command" from input JSON. Run via `tokio::process::Command::new("bash").arg("-c").arg(&command)`. Capture stdout + stderr. Return ToolOutput with combined output. If process exits non-zero, set is_error = true and include exit code in content.
   - No restrictions on bash access — this is a personal agent on a single-user VPS (per locked decision).

3. Create `crates/blufio-skill/src/builtin/http.rs`:
   - `HttpTool` struct holding `reqwest::Client`
   - Constructor: `fn new() -> Self` — create reqwest Client
   - Implements Tool:
     - name: "http"
     - description: "Make an HTTP request and return the response"
     - parameters_schema: `{ "type": "object", "properties": { "url": { "type": "string" }, "method": { "type": "string", "enum": ["GET", "POST", "PUT", "DELETE", "PATCH"], "default": "GET" }, "headers": { "type": "object" }, "body": { "type": "string" } }, "required": ["url"] }`
     - invoke: Extract url, method (default GET), optional headers and body. Use blufio-security SSRF check on the URL if available (import blufio_security::check_url or just validate URL is not private IP — use reqwest's built-in). Build and execute request. Return status code + response body (truncated to 50KB). If request fails, set is_error = true.
   - Add blufio-security as optional dep if it has SSRF prevention exports; otherwise, validate URL scheme is http/https only.

4. Create `crates/blufio-skill/src/builtin/file.rs`:
   - `FileTool` struct (unit struct)
   - Implements Tool:
     - name: "file"
     - description: "Read or write files on the filesystem"
     - parameters_schema: `{ "type": "object", "properties": { "action": { "type": "string", "enum": ["read", "write"] }, "path": { "type": "string" }, "content": { "type": "string", "description": "Content to write (required for write action)" } }, "required": ["action", "path"] }`
     - invoke: Extract action, path, optional content. For "read": use `tokio::fs::read_to_string`, return contents (truncated to 100KB). For "write": use `tokio::fs::write`. Return confirmation. On error, set is_error = true.
   - Full filesystem access — consistent with bash access (per locked decision).

5. Tests:
   - BashTool: invoke with "echo hello" returns "hello\n"
   - BashTool: invoke with "exit 1" returns is_error=true
   - BashTool: parameters_schema has required "command" field
   - HttpTool: parameters_schema has required "url" field (no live HTTP tests needed)
   - FileTool: invoke read on non-existent file returns is_error=true
   - FileTool: invoke write + read roundtrip in temp directory
   - register_builtins registers exactly 3 tools
  </action>
  <verify>cd /Users/suman/projects/github/blufio && cargo test -p blufio-skill -- builtin</verify>
  <done>BashTool executes commands, HttpTool makes requests, FileTool reads/writes files, all registered via register_builtins</done>
</task>

<task type="auto">
  <name>Task 3: Extend Anthropic types and SSE parser for tool_use/tool_result</name>
  <files>crates/blufio-core/src/types.rs, crates/blufio-core/src/error.rs, crates/blufio-anthropic/src/types.rs, crates/blufio-anthropic/src/client.rs, crates/blufio-anthropic/src/sse.rs</files>
  <action>
1. Add `BlufioError::Skill` variant to `crates/blufio-core/src/error.rs`:
   ```rust
   #[error("skill error: {message}")]
   Skill { message: String, source: Option<Box<dyn std::error::Error + Send + Sync>> },
   ```

2. Extend `ProviderStreamChunk` in `crates/blufio-core/src/types.rs`:
   - Add `tool_use: Option<ToolUseData>` field
   - Add `ToolUseData` struct: `{ id: String, name: String, input: serde_json::Value }`
   - These carry parsed tool calls from stream events to the agent loop

3. Extend `ProviderRequest` in `crates/blufio-core/src/types.rs`:
   - Add `tools: Option<Vec<serde_json::Value>>` field — tool definitions for the API
   - This allows the session actor to pass tool definitions to the provider

4. Extend `crates/blufio-anthropic/src/types.rs`:
   - Add `tools` field to `MessageRequest`: `#[serde(skip_serializing_if = "Option::is_none")] pub tools: Option<Vec<ToolDefinition>>`
   - Add `ToolDefinition` struct: `{ name: String, description: String, input_schema: serde_json::Value }`
   - Add `ToolUse` variant to `ApiContentBlock`: `#[serde(rename = "tool_use")] ToolUse { id: String, name: String, input: serde_json::Value }`
   - Add `ToolUse` variant to `ResponseContentBlock`: `#[serde(rename = "tool_use")] ToolUse { id: String, name: String, input: serde_json::Value }`
   - Add `ToolResult` variant to `ApiContentBlock`: `#[serde(rename = "tool_result")] ToolResult { tool_use_id: String, content: String, #[serde(skip_serializing_if = "Option::is_none")] is_error: Option<bool> }`
   - Add `SseContentBlockStart` handling for tool_use blocks (content_block with type "tool_use")

5. Extend `crates/blufio-anthropic/src/sse.rs` (SSE parser):
   - Track active tool_use blocks: maintain a HashMap<usize, (String, String, String)> mapping content block index to (tool_use_id, name, accumulated_partial_json)
   - On `content_block_start` with type "tool_use": store the id and name, initialize empty partial_json
   - On `content_block_delta` with `input_json_delta`: append partial_json to the accumulator for that block index
   - On `content_block_stop` for a tool_use block: parse the accumulated JSON, emit ProviderStreamChunk with tool_use data populated
   - Ensure text blocks continue to work as before (no regression)

6. Extend `crates/blufio-anthropic/src/client.rs`:
   - When building `MessageRequest` from `ProviderRequest`, map `tools` field: convert serde_json::Value tool definitions to `ToolDefinition` structs
   - Pass tools to MessageRequest if present

7. Tests:
   - Serialize MessageRequest with tools field
   - Deserialize tool_use ResponseContentBlock
   - Serialize ToolResult ApiContentBlock
   - SseDelta::InputJsonDelta accumulation across multiple deltas
   - Existing text streaming tests still pass (regression check)
  </action>
  <verify>cd /Users/suman/projects/github/blufio && cargo test -p blufio-anthropic && cargo test -p blufio-core -- types</verify>
  <done>Anthropic provider supports tool definitions in requests, parses tool_use from streaming responses, accumulates partial JSON for tool inputs</done>
</task>

</tasks>

<verification>
1. `cargo test -p blufio-skill` — all tool trait, registry, and builtin tests pass
2. `cargo test -p blufio-anthropic` — tool_use/tool_result types serialize/deserialize correctly, SSE parsing handles tool blocks
3. `cargo test -p blufio-core` — new error variant and extended types compile, existing tests still pass
4. `cargo check --workspace` — entire workspace compiles cleanly with new crate
</verification>

<success_criteria>
- blufio-skill crate exists with Tool trait, ToolRegistry, and 3 built-in tools
- BashTool can execute commands and return output
- HttpTool can make HTTP requests
- FileTool can read and write files
- Anthropic MessageRequest includes optional tools field
- SSE parser handles tool_use content blocks and accumulates partial JSON
- ProviderStreamChunk carries ToolUseData for tool invocations
- BlufioError::Skill variant exists for tool execution failures
- All tests pass, workspace compiles
</success_criteria>

<output>
After completion, create `.planning/phases/07-wasm-skill-sandbox/07-01-SUMMARY.md`
</output>
