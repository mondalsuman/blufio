---
phase: 07-wasm-skill-sandbox
plan: 03
type: execute
wave: 2
depends_on: ["07-01", "07-02"]
files_modified:
  - crates/blufio-skill/src/provider.rs
  - crates/blufio-skill/src/lib.rs
  - crates/blufio-agent/Cargo.toml
  - crates/blufio-agent/src/session.rs
  - crates/blufio-agent/src/lib.rs
  - crates/blufio/Cargo.toml
  - crates/blufio/src/main.rs
  - crates/blufio/src/serve.rs
  - crates/blufio/src/shell.rs
autonomous: true
requirements:
  - SKILL-04

must_haves:
  truths:
    - "SkillProvider implements ConditionalProvider and injects skill one-liners (name: description) into the conditional context zone for the LLM's prompt"
    - "When the LLM returns a tool_use response, the session FSM executes the tool via ToolRegistry, sends tool_result back, and re-calls the LLM"
    - "Tool calling loop has a max iteration cap (10 rounds) to prevent infinite tool-call loops"
    - "ToolRegistry with built-in tools and loaded WASM skills is wired into serve.rs and shell.rs"
    - "SkillProvider is registered as a ConditionalProvider with the ContextEngine"
    - "blufio skill subcommand supports init, list, and install operations"
    - "Tool definitions from ToolRegistry are passed to the Anthropic provider in every request"
    - "On tool invocation of a WASM skill, SKILL.md is loaded into the dynamic context if available"
  artifacts:
    - crates/blufio-skill/src/provider.rs
    - crates/blufio-agent/src/session.rs
    - crates/blufio/src/main.rs
    - crates/blufio/src/serve.rs
  key_links:
    - "SessionActor.handle_message detects stop_reason tool_use and loops through tool execution before returning final stream"
    - "SkillProvider.provide_context returns skill one-liners from ToolRegistry.list()"
    - "serve.rs creates ToolRegistry, registers builtins, loads skills, wires into SessionActor and ContextEngine"
    - "blufio skill init calls scaffold_skill, blufio skill list queries SkillStore"
---

<objective>
Wire the skill system into the agent loop: implement SkillProvider for progressive discovery, extend the session FSM with tool_use/tool_result handling, add the `blufio skill` CLI subcommand, and integrate everything in serve.rs and shell.rs.

Purpose: Connect all the pieces from Plans 01 and 02 into a working end-to-end system. After this plan, the LLM can see available tools in its prompt, decide to call them, execute them (built-in or WASM), receive results, and continue generating. This is the plan that makes skills actually work in the agent.

Output: SkillProvider (ConditionalProvider). Extended session FSM with ToolExecuting state and tool_use loop. CLI `blufio skill` subcommand. Full wiring in serve.rs and shell.rs.
</objective>

<execution_context>
@/Users/suman/.claude/get-shit-done/workflows/execute-plan.md
@/Users/suman/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/STATE.md
@.planning/ROADMAP.md
@.planning/phases/07-wasm-skill-sandbox/07-CONTEXT.md
@.planning/phases/07-wasm-skill-sandbox/07-RESEARCH.md
@.planning/phases/07-wasm-skill-sandbox/07-01-SUMMARY.md
@.planning/phases/07-wasm-skill-sandbox/07-02-SUMMARY.md

<interfaces>
<!-- Key types from Plans 01 and 02 that this plan depends on -->

From blufio-skill/src/tool.rs (Plan 01):
```rust
pub trait Tool: Send + Sync {
    fn name(&self) -> &str;
    fn description(&self) -> &str;
    fn parameters_schema(&self) -> serde_json::Value;
    async fn invoke(&self, input: serde_json::Value) -> Result<ToolOutput, BlufioError>;
}

pub struct ToolOutput { pub content: String, pub is_error: bool }

pub struct ToolRegistry {
    // register, get, list, tool_definitions methods
}
```

From blufio-skill/src/builtin/mod.rs (Plan 01):
```rust
pub fn register_builtins(registry: &mut ToolRegistry);
```

From blufio-core/src/types.rs (Plan 01 extensions):
```rust
pub struct ProviderStreamChunk {
    pub event_type: StreamEventType,
    pub text: Option<String>,
    pub usage: Option<TokenUsage>,
    pub error: Option<String>,
    pub tool_use: Option<ToolUseData>,
}
pub struct ToolUseData { pub id: String, pub name: String, pub input: serde_json::Value }

pub struct ProviderRequest {
    // ... existing fields ...
    pub tools: Option<Vec<serde_json::Value>>,
}
```

From blufio-skill/src/sandbox.rs (Plan 02):
```rust
pub struct WasmSkillRuntime { /* engine, manifests, modules */ }
impl WasmSkillRuntime {
    pub fn new() -> Result<Self, BlufioError>;
    pub fn load_skill(&mut self, manifest: SkillManifest, wasm_bytes: &[u8]) -> Result<(), BlufioError>;
    pub async fn invoke(&self, invocation: SkillInvocation) -> Result<SkillResult, BlufioError>;
    pub fn list_skills(&self) -> Vec<SkillManifest>;
}
```

From blufio-skill/src/store.rs (Plan 02):
```rust
pub struct SkillStore { /* conn */ }
impl SkillStore {
    pub fn new(conn: Arc<tokio_rusqlite::Connection>) -> Self;
    pub async fn install(...) -> Result<(), BlufioError>;
    pub async fn list(&self) -> Result<Vec<InstalledSkill>, BlufioError>;
}
```

From blufio-skill/src/scaffold.rs (Plan 02):
```rust
pub fn scaffold_skill(name: &str, target_dir: &Path) -> Result<(), BlufioError>;
```

From blufio-context/src/conditional.rs:
```rust
#[async_trait]
pub trait ConditionalProvider: Send + Sync {
    async fn provide_context(&self, session_id: &str) -> Result<Vec<ProviderMessage>, BlufioError>;
}
```

From blufio-agent/src/session.rs:
```rust
pub struct SessionActor {
    // ... existing fields (storage, provider, context_engine, budget_tracker, etc.) ...
}
impl SessionActor {
    pub async fn handle_message(&mut self, inbound: InboundMessage) -> Result<Pin<Box<dyn Stream<...>>>, BlufioError>;
    pub async fn persist_response(&mut self, full_text: &str, usage: Option<TokenUsage>) -> Result<(), BlufioError>;
}
```

From blufio-config/src/model.rs (Plan 02):
```rust
pub struct SkillConfig {
    pub skills_dir: String,
    pub default_fuel: u64,
    pub default_memory_mb: u32,
    pub default_epoch_timeout_secs: u64,
    pub max_skills_in_prompt: usize,
    pub enabled: bool,
}
```
</interfaces>
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement SkillProvider for progressive skill discovery</name>
  <files>crates/blufio-skill/src/provider.rs, crates/blufio-skill/src/lib.rs</files>
  <action>
1. Create `crates/blufio-skill/src/provider.rs`:
   - Add blufio-context as dependency to blufio-skill/Cargo.toml

   - `SkillProvider` struct:
     ```rust
     #[derive(Clone)]
     pub struct SkillProvider {
         registry: Arc<RwLock<ToolRegistry>>,
         max_skills_in_prompt: usize,
     }
     ```
   - Constructor: `fn new(registry: Arc<RwLock<ToolRegistry>>, max_skills_in_prompt: usize) -> Self`

   - Implement `ConditionalProvider` for `SkillProvider`:
     - `provide_context` returns a single ProviderMessage with role "user" containing:
       ```
       ## Available Tools
       tool_name: Brief description of what it does
       tool_name2: Brief description
       ...
       ```
     - If more tools than max_skills_in_prompt, show the first N and append: "... and M more tools available"
     - If no tools are registered, return empty Vec (no context injected)

   - The LLM sees this in the conditional zone of the prompt. It uses tool_use blocks to invoke tools when appropriate.

2. Update `crates/blufio-skill/src/lib.rs`:
   - Add `pub mod provider;`
   - Re-export: `pub use provider::SkillProvider;`

3. Tests:
   - SkillProvider with empty registry returns empty Vec
   - SkillProvider with 2 tools returns message with "## Available Tools" header and 2 lines
   - SkillProvider with 25 tools and max 20 truncates and shows "... and 5 more tools available"
   - SkillProvider message has role "user" (matching MemoryProvider pattern)
  </action>
  <verify>cd /Users/suman/projects/github/blufio && cargo test -p blufio-skill -- provider</verify>
  <done>SkillProvider implements ConditionalProvider, injects tool one-liners into prompt, respects max_skills_in_prompt cap</done>
</task>

<task type="auto">
  <name>Task 2: Extend SessionActor with tool_use/tool_result loop</name>
  <files>crates/blufio-agent/Cargo.toml, crates/blufio-agent/src/session.rs, crates/blufio-agent/src/lib.rs</files>
  <action>
1. Add blufio-skill as dependency to `crates/blufio-agent/Cargo.toml`.

2. Extend `SessionActor` in `crates/blufio-agent/src/session.rs`:
   - Add field: `tool_registry: Arc<RwLock<ToolRegistry>>`
   - Add field: `max_tool_iterations: usize` (default: 10)
   - Update constructor to accept these new fields
   - Add `ToolExecuting` variant to `SessionState` enum

3. Modify `handle_message` to support tool calling:
   - After the LLM stream is returned, the caller (agent loop in lib.rs) will consume the stream
   - The key change: instead of returning one stream, implement a loop pattern:

   Add a new method `pub async fn handle_message_with_tools`:
   - Calls the existing context assembly and LLM streaming logic
   - But after collecting the full response, checks if the response contains tool_use blocks
   - If tool_use blocks are present (stop_reason == "tool_use" equivalent, or ProviderStreamChunk has tool_use data):
     a. Transition to ToolExecuting state
     b. For each tool_use block:
        - Look up tool in tool_registry
        - If it's a WASM skill and a SKILL.md exists, log that we'd load it (actual dynamic zone injection is future work since it requires mid-turn context changes)
        - Call tool.invoke(input)
        - Build tool_result message with tool_use_id
     c. Append assistant message (with tool_use blocks) and user message (with tool_result blocks) to conversation history
     d. Re-call the LLM with the updated conversation (including tool results)
     e. Check iteration count, trap if > max_tool_iterations
   - If no tool_use blocks: proceed normally (return text response)

   Implementation note: The tool loop should be in the agent loop (lib.rs handle_inbound), not deep inside session.rs, because it needs to consume and re-stream. Add a helper method to SessionActor:
   - `pub async fn execute_tools(&self, tool_uses: Vec<ToolUseData>) -> Result<Vec<ToolResultMessage>, BlufioError>` — executes tools and returns results
   - The agent loop orchestrates: stream -> detect tool_use -> execute_tools -> re-stream -> etc.

4. Extend the agent loop in `crates/blufio-agent/src/lib.rs` `handle_inbound`:
   - After consuming the stream and collecting full_response:
   - Check if any ProviderStreamChunk had tool_use data
   - If yes, enter tool execution loop:
     ```
     loop (max 10 iterations):
       collect tool_use blocks from stream
       call session.execute_tools(tool_uses)
       build tool_result messages
       persist assistant msg (with tool_use) + user msg (with tool_result)
       re-call LLM with updated context
       consume new stream
       if no more tool_use: break
     ```
   - On max iterations: append a system note "Maximum tool iterations reached" and let the LLM respond with text

5. The ProviderRequest must include tool definitions. Modify the context assembly or ProviderRequest building to include `tools` from the ToolRegistry:
   - In session.rs, when building the ProviderRequest for streaming, set `tools: Some(tool_registry.read().await.tool_definitions())`

6. Tests:
   - SessionActor constructor accepts tool_registry
   - execute_tools with empty tool_uses returns empty results
   - ToolExecuting state display works
   - max_tool_iterations constant is 10
   - Note: Full end-to-end tool loop tests require mock provider — add structural tests for the tool execution method
  </action>
  <verify>cd /Users/suman/projects/github/blufio && cargo test -p blufio-agent && cargo check -p blufio-agent</verify>
  <done>SessionActor supports tool execution, agent loop implements tool_use/tool_result loop with max iteration cap</done>
</task>

<task type="auto">
  <name>Task 3: Add blufio skill CLI subcommand and wire everything in serve.rs/shell.rs</name>
  <files>crates/blufio/Cargo.toml, crates/blufio/src/main.rs, crates/blufio/src/serve.rs, crates/blufio/src/shell.rs</files>
  <action>
1. Add blufio-skill as dependency to `crates/blufio/Cargo.toml`.

2. Extend CLI in `crates/blufio/src/main.rs`:
   - Add `Skill` variant to `Commands` enum:
     ```rust
     /// Manage Blufio skills.
     Skill {
         #[command(subcommand)]
         action: SkillCommands,
     },
     ```
   - Add `SkillCommands` enum:
     ```rust
     #[derive(Subcommand, Debug)]
     enum SkillCommands {
         /// Create a new skill project scaffold.
         Init {
             /// Name of the skill to create.
             name: String,
         },
         /// List all installed skills.
         List,
         /// Install a WASM skill from a file.
         Install {
             /// Path to the .wasm file.
             wasm_path: String,
             /// Path to the skill.toml manifest.
             manifest_path: String,
         },
         /// Remove an installed skill.
         Remove {
             /// Name of the skill to remove.
             name: String,
         },
     }
     ```
   - Implement handlers:
     - `Init`: Call `blufio_skill::scaffold_skill(&name, &Path::new("."))`. Print success message.
     - `List`: Open DB, create SkillStore, call list(), print table of name, version, description, verification_status.
     - `Install`: Read manifest from manifest_path, read WASM bytes, create SkillStore, call install(). Print capabilities for user review. Print success.
     - `Remove`: Open DB, create SkillStore, call remove(). Print success.

3. Wire skill system in `crates/blufio/src/serve.rs`:
   - After initializing memory system and before creating agent loop:
     ```rust
     // Initialize skill system (if enabled).
     let (tool_registry, skill_provider) = if config.skill.enabled {
         match initialize_skills(&config).await {
             Ok((tr, sp)) => (tr, Some(sp)),
             Err(e) => {
                 warn!(error = %e, "skill system initialization failed, continuing with builtins only");
                 let mut reg = ToolRegistry::new();
                 blufio_skill::builtin::register_builtins(&mut reg);
                 (Arc::new(RwLock::new(reg)), None)
             }
         }
     } else {
         let mut reg = ToolRegistry::new();
         blufio_skill::builtin::register_builtins(&mut reg);
         info!("skill system disabled, built-in tools only");
         (Arc::new(RwLock::new(reg)), None)
     };

     // Register SkillProvider with context engine.
     if let Some(sp) = skill_provider {
         context_engine.add_conditional_provider(Box::new(sp));
     }
     ```
   - Create `initialize_skills` function:
     - Open SkillStore connection
     - Create ToolRegistry, register builtins
     - Create WasmSkillRuntime
     - Load installed skills from SkillStore
     - For each installed skill: read WASM file, load into runtime, create a WasmTool wrapper that implements Tool trait and delegates to WasmSkillRuntime.invoke()
     - Register WASM tools in ToolRegistry
     - Create SkillProvider with ToolRegistry
     - Return (Arc<RwLock<ToolRegistry>>, SkillProvider)
   - Pass tool_registry to AgentLoop::new (extend constructor) and to SessionActor

4. Wire in `crates/blufio/src/shell.rs`:
   - Same pattern: create ToolRegistry with builtins, optionally load WASM skills
   - Pass to session actor

5. Update AgentLoop::new signature to accept `tool_registry: Arc<RwLock<ToolRegistry>>` and pass it through to SessionActor creation.

6. Tests:
   - CLI parses `blufio skill init my-skill`
   - CLI parses `blufio skill list`
   - CLI parses `blufio skill install path/to/skill.wasm path/to/skill.toml`
   - CLI parses `blufio skill remove my-skill`
  </action>
  <verify>cd /Users/suman/projects/github/blufio && cargo test -p blufio && cargo check --workspace</verify>
  <done>blufio skill CLI works, serve.rs and shell.rs wire tool registry, skill provider registered with context engine, agent loop handles tool_use/tool_result</done>
</task>

</tasks>

<verification>
1. `cargo test --workspace` — all tests across all crates pass
2. `cargo check --workspace` — full workspace compiles
3. `cargo clippy --workspace` — no warnings
4. Verify skill one-liners would appear in prompt (SkillProvider test)
5. Verify tool definitions are serialized in Anthropic request format
6. Verify CLI `blufio skill init` creates valid project structure
</verification>

<success_criteria>
- SkillProvider injects tool one-liners into the conditional zone of the prompt
- Session FSM handles tool_use responses: executes tools, returns tool_result, re-calls LLM
- Tool loop capped at 10 iterations to prevent infinite loops
- blufio skill init/list/install/remove CLI commands work
- serve.rs and shell.rs wire ToolRegistry and SkillProvider
- Tool definitions passed to Anthropic provider in every request
- Built-in tools and WASM skills are indistinguishable from the LLM's perspective
- All tests pass, workspace compiles, no clippy warnings
</success_criteria>

<output>
After completion, create `.planning/phases/07-wasm-skill-sandbox/07-03-SUMMARY.md`
</output>
