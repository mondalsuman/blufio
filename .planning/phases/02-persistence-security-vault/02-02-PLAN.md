---
phase: 02-persistence-security-vault
plan: 02
type: execute
wave: 2
depends_on:
  - 02-01
files_modified:
  - Cargo.toml
  - crates/blufio-vault/Cargo.toml
  - crates/blufio-vault/src/lib.rs
  - crates/blufio-vault/src/vault.rs
  - crates/blufio-vault/src/crypto.rs
  - crates/blufio-vault/src/kdf.rs
  - crates/blufio-vault/src/prompt.rs
  - crates/blufio-vault/src/migration.rs
  - crates/blufio-security/Cargo.toml
  - crates/blufio-security/src/lib.rs
  - crates/blufio-security/src/tls.rs
  - crates/blufio-security/src/ssrf.rs
  - crates/blufio-security/src/redact.rs
  - crates/blufio/Cargo.toml
  - crates/blufio/src/main.rs
autonomous: true
requirements:
  - SEC-01
  - SEC-03
  - SEC-04
  - SEC-08
  - SEC-09
  - SEC-10

must_haves:
  truths:
    - "API keys and bot tokens stored in the vault are encrypted with AES-256-GCM -- raw values never written to disk"
    - "Vault key is derived from passphrase via Argon2id and never stored on disk -- only held in process memory"
    - "Changing the passphrase re-wraps the master key without re-encrypting all secrets"
    - "Vault passphrase can be provided via TTY prompt or BLUFIO_VAULT_KEY env var for headless deployments"
    - "vault_startup_check() returns error with clear message if vault exists but passphrase is not provided"
    - "Plaintext secrets found in TOML config are auto-migrated into vault and removed from config file"
    - "SecurityConfig.bind_address defaults to 127.0.0.1 (config established; runtime binding enforcement is Phase 3)"
    - "build_secure_client() enforces TLS 1.2+ for remote connections; validate_url() rejects non-TLS URLs to non-localhost targets"
    - "RedactingWriter replaces known API key regex patterns and exact vault-stored values with [REDACTED]"
    - "SsrfSafeResolver blocks RFC 1918/4193/link-local IP ranges by default with configurable allowlist"
    - "Security utility functions return BlufioError::Security and log at ERROR level on violations"
    - "blufio config set-secret <key> CLI command stores encrypted secrets in the vault"
    - "blufio config list-secrets CLI command displays secret names with masked previews -- values never fully shown"
  artifacts:
    - path: "crates/blufio-vault/src/crypto.rs"
      provides: "AES-256-GCM seal/open operations with random nonces"
      contains: "AES_256_GCM"
    - path: "crates/blufio-vault/src/kdf.rs"
      provides: "Argon2id key derivation from passphrase"
      contains: "Argon2id"
    - path: "crates/blufio-vault/src/vault.rs"
      provides: "Vault lifecycle: create, unlock, store, retrieve, list, delete secrets"
      exports: ["Vault", "store_secret", "retrieve_secret", "list_secrets"]
    - path: "crates/blufio-vault/src/prompt.rs"
      provides: "Passphrase acquisition via TTY or env var"
      contains: "BLUFIO_VAULT_KEY"
    - path: "crates/blufio-vault/src/migration.rs"
      provides: "Auto-migration of plaintext config secrets to vault"
      contains: "migrate_plaintext_secrets"
    - path: "crates/blufio-security/src/tls.rs"
      provides: "TLS-enforced reqwest client builder"
      contains: "min_tls_version"
    - path: "crates/blufio-security/src/ssrf.rs"
      provides: "SSRF-safe DNS resolver blocking private IPs"
      contains: "is_private"
    - path: "crates/blufio-security/src/redact.rs"
      provides: "Secret redaction for log output"
      contains: "REDACTED"
  key_links:
    - from: "crates/blufio-vault/src/vault.rs"
      to: "crates/blufio-storage (vault_entries + vault_meta tables)"
      via: "SQLite storage of encrypted entries and key material"
      pattern: "vault_entries|vault_meta"
    - from: "crates/blufio-vault/src/crypto.rs"
      to: "ring::aead::AES_256_GCM"
      via: "AEAD seal/open with random 96-bit nonces"
      pattern: "LessSafeKey|seal_in_place|open_in_place"
    - from: "crates/blufio-vault/src/kdf.rs"
      to: "argon2::Argon2 with Argon2id"
      via: "hash_password_into for raw 32-byte key derivation"
      pattern: "hash_password_into"
    - from: "crates/blufio-security/src/ssrf.rs"
      to: "reqwest::dns::Resolve"
      via: "Custom DNS resolver filtering private IPs before connection"
      pattern: "impl Resolve"
    - from: "crates/blufio-security/src/redact.rs"
      to: "tracing_subscriber / std::io::Write"
      via: "Wrapping log output writer with regex + exact-match redaction"
      pattern: "RedactingWriter|impl Write"
    - from: "crates/blufio/src/main.rs"
      to: "crates/blufio-vault/src/vault.rs"
      via: "CLI set-secret/list-secrets subcommands call vault.store_secret() and vault.list_secrets()"
      pattern: "store_secret|list_secrets"
---

<objective>
Create the blufio-vault crate (AES-256-GCM encrypted credential storage with Argon2id key derivation) and the blufio-security crate (TLS enforcement, SSRF prevention, secret redaction), completing the security foundation for all subsequent phases.

Purpose: No secret should ever be stored in plaintext or leaked through logs. No connection should bypass TLS to remote hosts. No outbound request should reach private IP ranges. These are security invariants that every future phase inherits -- the agent loop (Phase 3), the context engine (Phase 4), and the skill sandbox (Phase 7) all build on these guarantees.

Output: Two new crates -- `blufio-vault` providing encrypted credential storage with key wrapping, and `blufio-security` providing network security enforcement and log redaction.
</objective>

<execution_context>
@/Users/suman/.claude/get-shit-done/workflows/execute-plan.md
@/Users/suman/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-persistence-security-vault/02-RESEARCH.md
@.planning/phases/02-persistence-security-vault/02-CONTEXT.md
@.planning/phases/02-persistence-security-vault/02-01-SUMMARY.md

<interfaces>
<!-- Key types and contracts from Plan 01. Executor needs these. -->

From crates/blufio-storage/src/database.rs (created in Plan 01):
```rust
pub struct Database {
    conn: tokio_rusqlite::Connection,
}

impl Database {
    pub async fn open(path: &str) -> Result<Self, BlufioError>;
    pub async fn close(&self) -> Result<(), BlufioError>;
    pub fn connection(&self) -> &tokio_rusqlite::Connection;
}
```

From crates/blufio-core/src/error.rs (extended in Plan 01):
```rust
pub enum BlufioError {
    Storage { source: Box<dyn std::error::Error + Send + Sync> },
    Vault(String),
    Security(String),
    // ...
}
```

From crates/blufio-config/src/model.rs (extended in Plan 01):
```rust
pub struct VaultConfig {
    pub kdf_memory_cost: u32,   // default 65536
    pub kdf_iterations: u32,    // default 3
    pub kdf_parallelism: u32,   // default 4
}

pub struct SecurityConfig {
    pub bind_address: String,          // default "127.0.0.1"
    pub require_tls: bool,             // default true
    pub allowed_private_ips: Vec<String>,  // default empty
}

pub struct BlufioConfig {
    pub vault: VaultConfig,
    pub security: SecurityConfig,
    pub storage: StorageConfig,
    pub telegram: TelegramConfig,
    pub anthropic: AnthropicConfig,
    // ...
}
```

From crates/blufio-storage/migrations/V1__initial_schema.sql (created in Plan 01):
```sql
CREATE TABLE IF NOT EXISTS vault_entries (
    name TEXT PRIMARY KEY NOT NULL,
    ciphertext BLOB NOT NULL,
    nonce BLOB NOT NULL,
    created_at TEXT NOT NULL DEFAULT (strftime('%Y-%m-%dT%H:%M:%fZ', 'now')),
    updated_at TEXT NOT NULL DEFAULT (strftime('%Y-%m-%dT%H:%M:%fZ', 'now'))
);

CREATE TABLE IF NOT EXISTS vault_meta (
    key TEXT PRIMARY KEY NOT NULL,
    value BLOB NOT NULL
);
```
</interfaces>
</context>

<tasks>

<task type="auto" tdd="true">
  <name>Task 1: Implement blufio-vault crate with AES-256-GCM encryption, Argon2id KDF, and key wrapping</name>
  <files>
    crates/blufio-vault/Cargo.toml,
    crates/blufio-vault/src/lib.rs,
    crates/blufio-vault/src/crypto.rs,
    crates/blufio-vault/src/kdf.rs,
    crates/blufio-vault/src/prompt.rs,
    crates/blufio-vault/src/vault.rs
  </files>
  <behavior>
    - Test 1: seal() + open() round-trips data correctly with AES-256-GCM
    - Test 2: seal() produces different ciphertext for same plaintext (random nonce)
    - Test 3: open() with wrong key returns error (authentication failure)
    - Test 4: derive_key() produces consistent 32-byte output for same passphrase+salt
    - Test 5: derive_key() produces different output for different passphrases
    - Test 6: Vault::create() generates random master key, wraps it with passphrase-derived key, stores wrapped key + salt + nonce in vault_meta
    - Test 7: Vault::unlock() derives key from passphrase, unwraps master key, holds it only in memory
    - Test 8: Vault::store_secret() encrypts value with master key, stores ciphertext+nonce in vault_entries
    - Test 9: Vault::retrieve_secret() decrypts and returns plaintext
    - Test 10: Vault::list_secrets() returns names + masked previews (e.g., "sk-...4f2b")
    - Test 11: Vault::change_passphrase() re-wraps master key without re-encrypting secrets
    - Test 12: get_vault_passphrase() reads from BLUFIO_VAULT_KEY env var when set
    - Test 13: Vault operations with wrong passphrase fail with clear error message
  </behavior>
  <action>
**Step 1: Create crates/blufio-vault/Cargo.toml.**

```toml
[package]
name = "blufio-vault"
version.workspace = true
edition.workspace = true
license.workspace = true
repository.workspace = true
authors.workspace = true
publish = false
description = "AES-256-GCM encrypted credential vault for the Blufio agent framework"

[dependencies]
blufio-core.path = "../blufio-core"
blufio-config.path = "../blufio-config"
ring.workspace = true
argon2.workspace = true
secrecy.workspace = true
zeroize.workspace = true
rand.workspace = true
rpassword.workspace = true
tokio-rusqlite.workspace = true
rusqlite.workspace = true
tracing.workspace = true
thiserror.workspace = true

[dev-dependencies]
tokio = { workspace = true, features = ["macros", "rt-multi-thread"] }
tempfile = "3"
```

**Step 2: Create crates/blufio-vault/src/crypto.rs.**

Implement low-level AES-256-GCM operations using `ring::aead`:

```rust
use ring::aead::{self, LessSafeKey, UnboundKey, Nonce, Aad, AES_256_GCM};
use ring::rand::{SystemRandom, SecureRandom};

/// Encrypt plaintext with AES-256-GCM using a random 96-bit nonce.
/// Returns (ciphertext_with_tag, nonce_bytes).
pub fn seal(key: &[u8; 32], plaintext: &[u8]) -> Result<(Vec<u8>, [u8; 12]), BlufioError>

/// Decrypt ciphertext with AES-256-GCM.
/// Returns plaintext.
pub fn open(key: &[u8; 32], nonce_bytes: &[u8; 12], ciphertext: &[u8]) -> Result<Vec<u8>, BlufioError>
```

Key implementation details:
- `seal()` generates a random 96-bit nonce via `SystemRandom` for EVERY encryption operation (per research pitfall 2 -- never reuse nonces)
- `seal()` returns the nonce alongside ciphertext so the caller can store both
- `open()` takes the nonce that was stored alongside the ciphertext
- Use `LessSafeKey` (not `SealingKey`/`OpeningKey`) because we manage nonces ourselves
- `Aad::empty()` for additional authenticated data (no AAD needed for vault)
- Map all ring errors to `BlufioError::Vault`

**Step 3: Create crates/blufio-vault/src/kdf.rs.**

Implement Argon2id key derivation:

```rust
use argon2::{Argon2, Algorithm, Version, Params};
use zeroize::Zeroizing;

/// Derive a 32-byte key from passphrase using Argon2id.
/// Parameters are read from VaultConfig.
pub fn derive_key(
    passphrase: &[u8],
    salt: &[u8; 16],
    memory_cost: u32,
    iterations: u32,
    parallelism: u32,
) -> Result<Zeroizing<[u8; 32]>, BlufioError>
```

Implementation:
- Create `Params::new(memory_cost, iterations, parallelism, Some(32))` for 32-byte output
- Create `Argon2::new(Algorithm::Argon2id, Version::V0x13, params)`
- Call `argon2.hash_password_into(passphrase, salt, output)`
- Wrap output in `Zeroizing<[u8; 32]>` for automatic memory zeroing on drop
- Generate salt via `ring::rand::SystemRandom` (16 bytes) -- provide a `generate_salt()` helper

**Step 4: Create crates/blufio-vault/src/prompt.rs.**

Implement passphrase acquisition per user decisions:

```rust
use secrecy::SecretString;

/// Get vault passphrase from env var or TTY prompt.
/// Priority: BLUFIO_VAULT_KEY env var > interactive TTY prompt.
pub fn get_vault_passphrase() -> Result<SecretString, BlufioError>
```

- Check `std::env::var("BLUFIO_VAULT_KEY")` first (headless/Docker/systemd)
- If not set and `stdin().is_terminal()`, use `rpassword::read_password()` with `eprint!("Vault passphrase: ")`
- If neither available, return `BlufioError::Vault("No passphrase provided. Set BLUFIO_VAULT_KEY or run interactively.")`
- Wrap result in `SecretString` for secure memory handling

Also provide `get_vault_passphrase_with_confirm()` for vault creation (prompts twice, checks match).

**Step 5: Create crates/blufio-vault/src/vault.rs.**

The main Vault struct orchestrates all operations:

```rust
use secrecy::SecretBox;
use tokio_rusqlite::Connection;

pub struct Vault {
    /// The unwrapped master key -- only in memory, never on disk
    master_key: SecretBox<[u8; 32]>,
    /// Database connection for vault_entries and vault_meta tables
    conn: Connection,
}
```

Operations:
- `Vault::exists(conn) -> Result<bool, _>` -- check if vault_meta has 'wrapped_master_key' entry
- `Vault::create(conn, passphrase, config) -> Result<Vault, _>`:
  1. Generate random 32-byte master key via `SystemRandom`
  2. Generate random 16-byte salt
  3. Derive wrapping key from passphrase+salt via `kdf::derive_key()`
  4. Encrypt master key with wrapping key via `crypto::seal()`
  5. Store in vault_meta: `wrapped_master_key` (ciphertext), `master_key_nonce`, `kdf_salt`, `kdf_params` (JSON of memory/iterations/parallelism)
  6. Return Vault with unwrapped master key in memory

- `Vault::unlock(conn, passphrase, config) -> Result<Vault, _>`:
  1. Read `kdf_salt`, `kdf_params`, `wrapped_master_key`, `master_key_nonce` from vault_meta
  2. Derive wrapping key from passphrase+salt
  3. Decrypt master key via `crypto::open()`
  4. If decryption fails -> clear error: "Invalid passphrase or corrupted vault"
  5. Return Vault with unwrapped master key in memory

- `vault.store_secret(name, plaintext) -> Result<(), _>`:
  1. Encrypt plaintext with master key via `crypto::seal()`
  2. INSERT OR REPLACE into vault_entries (name, ciphertext, nonce)

- `vault.retrieve_secret(name) -> Result<Option<SecretString>, _>`:
  1. SELECT ciphertext, nonce from vault_entries WHERE name = ?
  2. Decrypt with master key via `crypto::open()`
  3. Return as SecretString

- `vault.list_secrets() -> Result<Vec<(String, String)>, _>`:
  1. For each vault entry: retrieve, mask with `mask_secret()` helper
  2. Return Vec of (name, masked_preview) tuples
  3. mask_secret("sk-ant-api03-abc123xyz") -> "sk-...xyz" format

- `vault.delete_secret(name) -> Result<(), _>`:
  1. DELETE FROM vault_entries WHERE name = ?

- `vault.change_passphrase(old_passphrase, new_passphrase, config) -> Result<(), _>`:
  1. Verify old passphrase can unwrap master key
  2. Generate new salt
  3. Derive new wrapping key from new passphrase
  4. Re-wrap master key with new wrapping key
  5. Update vault_meta entries (wrapped key, nonce, salt)
  6. Secrets remain untouched -- only master key re-wrapped

All vault_meta and vault_entries access uses `conn.call()` pattern (single-writer through tokio-rusqlite).

**Step 6: Create crates/blufio-vault/src/lib.rs.**

Public API re-exports:
```rust
pub mod crypto;
pub mod kdf;
pub mod prompt;
pub mod vault;
pub mod migration;

pub use vault::Vault;
pub use prompt::get_vault_passphrase;
```

**Step 7: Write comprehensive tests.**

- crypto tests: seal/open round-trip, different nonces per seal, wrong-key rejection
- kdf tests: consistent output for same input, different output for different passphrase
- vault tests: full lifecycle (create -> store -> retrieve -> list -> delete -> change_passphrase)
- Use tempfile for test database, create vault tables via `refinery` or manual SQL setup

IMPORTANT: All `.rs` files MUST have SPDX dual-license header. Use `secrecy::SecretBox` (not the deprecated `Secret<T>` from secrecy 0.8 -- per research state-of-the-art section). Use `Zeroizing` for all intermediate key material.
  </action>
  <verify>
    <automated>cd /Users/suman/projects/github/blufio && cargo test -p blufio-vault -- --nocapture 2>&1</automated>
  </verify>
  <done>
    - AES-256-GCM seal/open works correctly with random nonces per encryption
    - Argon2id KDF derives consistent keys with configurable parameters
    - Vault create/unlock lifecycle works with key wrapping pattern
    - store_secret/retrieve_secret round-trips plaintext through encryption
    - list_secrets returns masked previews (sk-...4f2b format)
    - change_passphrase re-wraps master key without touching encrypted secrets
    - Passphrase prompt reads from BLUFIO_VAULT_KEY env var
    - Wrong passphrase produces clear error message
    - All secret material uses SecretBox/Zeroizing for memory safety
    - All tests pass with no clippy warnings
  </done>
</task>

<task type="auto" tdd="true">
  <name>Task 2: Implement blufio-security crate with TLS enforcement, SSRF prevention, and secret redaction</name>
  <files>
    crates/blufio-security/Cargo.toml,
    crates/blufio-security/src/lib.rs,
    crates/blufio-security/src/tls.rs,
    crates/blufio-security/src/ssrf.rs,
    crates/blufio-security/src/redact.rs
  </files>
  <behavior>
    - Test 1: build_secure_client() returns reqwest::Client with TLS 1.2+ minimum
    - Test 2: Secure client rejects HTTP URLs to non-localhost addresses
    - Test 3: Secure client allows HTTP to 127.0.0.1 and ::1 (localhost exempt from TLS)
    - Test 4: SsrfSafeResolver blocks connections to 10.x.x.x, 172.16-31.x.x, 192.168.x.x, 127.x.x.x, 169.254.x.x, 0.0.0.0
    - Test 5: SsrfSafeResolver blocks IPv6 loopback (::1), unique-local (fc00::/7), link-local (fe80::/10)
    - Test 6: SsrfSafeResolver allows connections to public IPs
    - Test 7: SsrfSafeResolver allows connections to IPs in allowed_private_ips config
    - Test 8: RedactingWriter replaces known API key patterns with [REDACTED] (sk-ant-*, Bearer tokens)
    - Test 9: RedactingWriter replaces exact vault-stored values with [REDACTED]
    - Test 10: RedactingWriter passes through non-sensitive text unchanged
    - Test 11: is_localhost() correctly identifies 127.0.0.1, ::1, localhost
  </behavior>
  <action>
**Step 1: Create crates/blufio-security/Cargo.toml.**

```toml
[package]
name = "blufio-security"
version.workspace = true
edition.workspace = true
license.workspace = true
repository.workspace = true
authors.workspace = true
publish = false
description = "Network security enforcement (TLS, SSRF prevention, secret redaction) for the Blufio agent framework"

[dependencies]
blufio-core.path = "../blufio-core"
blufio-config.path = "../blufio-config"
reqwest.workspace = true
regex.workspace = true
tracing.workspace = true
thiserror.workspace = true
once_cell = "1"

[dev-dependencies]
tokio = { workspace = true, features = ["macros", "rt-multi-thread"] }
```

NOTE: `once_cell` may not be needed if `std::sync::LazyLock` (stabilized in Rust 1.80) is available with edition 2024. Check if the project's Rust version (1.85) supports `LazyLock`. If so, use `std::sync::LazyLock` instead of `once_cell::sync::Lazy` for compiled regex patterns.

**Step 2: Create crates/blufio-security/src/tls.rs.**

TLS enforcement for all outbound HTTP connections:

```rust
/// Build a reqwest::Client with security defaults.
/// - Minimum TLS 1.2 for all connections
/// - SSRF-safe DNS resolver (blocks private IPs)
/// - Localhost connections exempt from TLS requirement
pub fn build_secure_client(config: &SecurityConfig) -> Result<reqwest::Client, BlufioError>
```

Implementation:
- Use `reqwest::ClientBuilder::new()`
- `.min_tls_version(reqwest::tls::Version::TLS_1_2)`
- `.dns_resolver(Arc::new(SsrfSafeResolver::new(config.allowed_private_ips.clone())))` (from ssrf module)
- `.https_only(false)` -- we handle TLS enforcement at a higher level because localhost must be exempt. Alternatively, use a custom redirect policy or build two clients (one for localhost, one for remote). The simplest approach: build one client with SSRF resolver, and have a helper function that validates URLs:
  - `validate_url(url) -> Result<(), BlufioError>` checks if URL target is localhost; if not localhost and scheme is not https, return `BlufioError::Security("TLS required for remote connections")`
  - This validation is called before making requests, not enforced at the reqwest level

Also provide:
```rust
/// Check if an address is localhost (127.0.0.1, ::1, "localhost").
pub fn is_localhost(addr: &str) -> bool
```

**Step 3: Create crates/blufio-security/src/ssrf.rs.**

Custom DNS resolver that blocks private IPs:

```rust
use reqwest::dns::{Resolve, Resolving, Name};
use std::net::{IpAddr, Ipv4Addr, Ipv6Addr, SocketAddr};

pub struct SsrfSafeResolver {
    allowed_private_ips: Vec<IpAddr>,
}

impl SsrfSafeResolver {
    pub fn new(allowed: Vec<String>) -> Self { /* parse IPs */ }

    /// Check if an IP is in a private/reserved range.
    pub fn is_private(ip: &IpAddr) -> bool {
        match ip {
            IpAddr::V4(v4) => {
                v4.is_private()           // 10.0.0.0/8, 172.16.0.0/12, 192.168.0.0/16
                || v4.is_loopback()       // 127.0.0.0/8
                || v4.is_link_local()     // 169.254.0.0/16
                || v4.is_broadcast()      // 255.255.255.255
                || v4.is_unspecified()    // 0.0.0.0
                || *v4 == Ipv4Addr::new(169, 254, 169, 254)  // AWS metadata
            }
            IpAddr::V6(v6) => {
                v6.is_loopback()          // ::1
                || v6.is_unspecified()    // ::
                || (v6.segments()[0] & 0xfe00) == 0xfc00  // fc00::/7 unique local
                || (v6.segments()[0] & 0xffc0) == 0xfe80  // fe80::/10 link-local
            }
        }
    }
}

impl Resolve for SsrfSafeResolver {
    fn resolve(&self, name: Name) -> Resolving {
        // 1. Resolve DNS normally (use tokio::net::lookup_host or std::net::ToSocketAddrs)
        // 2. Filter resolved IPs: remove any that are private AND not in allowed list
        // 3. If all IPs filtered out, return error: "SSRF blocked: {name} resolves to private IP"
        // 4. Log any allowed private IP accesses at INFO level
        // 5. Return filtered addresses
    }
}
```

Key points:
- Resolve DNS ONCE, filter IPs, then reqwest connects to the filtered results directly. This prevents DNS rebinding attacks (per research pitfall 5).
- The `Resolve` trait returns a `Resolving` which is `Pin<Box<dyn Future<Output = Result<Addrs, ...>>>>`. Use `Box::pin(async move { ... })`.
- `Addrs` is `Box<dyn Iterator<Item = SocketAddr>>`. Convert filtered IPs to `SocketAddr` with port 0 (reqwest ignores the port, uses its own).
- Log blocked attempts at ERROR level per user decision: "Security violations hard-fail the operation immediately and log at ERROR level"
- Log allowed private IP accesses at INFO level per user decision: "all allowlisted connections logged"

**Step 4: Create crates/blufio-security/src/redact.rs.**

Secret redaction for log output. Two complementary mechanisms:

Mechanism 1 -- Regex-based pattern matching for known secret formats:
```rust
/// Known secret patterns to redact from logs.
static REDACTION_PATTERNS: LazyLock<Vec<Regex>> = LazyLock::new(|| vec![
    // Anthropic API keys: sk-ant-api03-...
    Regex::new(r"sk-ant-[a-zA-Z0-9_-]{20,}").unwrap(),
    // Generic secret keys: sk-...
    Regex::new(r"sk-[a-zA-Z0-9]{20,}").unwrap(),
    // Bearer tokens in headers
    Regex::new(r"Bearer\s+[a-zA-Z0-9._\-]+").unwrap(),
    // Telegram bot tokens: 123456:ABC-DEF1234ghIkl-zyx57W2v1u123ew11
    Regex::new(r"\d{8,10}:[a-zA-Z0-9_-]{35}").unwrap(),
    // Generic base64-encoded secrets (long strings that look like keys)
    Regex::new(r"(?:api[_-]?key|secret|token|password|credential)\s*[=:]\s*['\"]?([a-zA-Z0-9+/=_\-]{20,})['\"]?").unwrap(),
]);
```

Mechanism 2 -- Exact value matching for vault-stored secrets:
```rust
pub struct RedactingWriter<W> {
    inner: W,
    patterns: &'static [Regex],
    vault_values: Arc<RwLock<Vec<String>>>,
}
```

The `vault_values` list is populated dynamically when secrets are loaded from the vault. Provide:
- `RedactingWriter::new(inner, vault_values)` -- constructor
- `RedactingWriter::add_vault_value(value)` -- add a new secret to the redaction list
- `impl Write for RedactingWriter<W>` -- intercepts output, applies regex + exact match replacement

Also provide a standalone function for use outside the logging pipeline:
```rust
/// Redact secrets from a string (for error messages, debug output, etc.)
pub fn redact(input: &str, vault_values: &[String]) -> String
```

**Step 5: Create crates/blufio-security/src/lib.rs.**

Public API:
```rust
pub mod tls;
pub mod ssrf;
pub mod redact;

pub use tls::{build_secure_client, is_localhost, validate_url};
pub use ssrf::SsrfSafeResolver;
pub use redact::{RedactingWriter, redact};
```

**Step 6: Write tests.**

- tls tests: Client creation succeeds, validate_url blocks non-TLS remote URLs, allows localhost HTTP
- ssrf tests: Comprehensive IP classification tests (all private ranges blocked, public allowed, allowlist works). Test `is_private()` directly with known IPs. Note: full integration test with actual DNS resolution may be flaky -- test `is_private()` logic thoroughly, and test `Resolve` trait with mocked DNS if possible.
- redact tests: Each regex pattern catches its target format, vault values are redacted exactly, non-sensitive text passes through unchanged, partial matches within words handled correctly

IMPORTANT: All `.rs` files MUST have SPDX dual-license header. Security violations MUST return `BlufioError::Security` (not panic or silently continue) per user decision.
  </action>
  <verify>
    <automated>cd /Users/suman/projects/github/blufio && cargo test -p blufio-security -- --nocapture 2>&1</automated>
  </verify>
  <done>
    - TLS enforcement: build_secure_client creates client with TLS 1.2+ minimum
    - TLS exemption: localhost connections (127.0.0.1, ::1) are exempt from TLS requirement
    - SSRF prevention: all RFC 1918/4193/link-local ranges blocked, public IPs allowed
    - SSRF allowlist: configured private IPs are permitted, accesses logged
    - Secret redaction: known patterns (sk-ant-*, Bearer, Telegram tokens) caught by regex
    - Secret redaction: vault-stored values caught by exact match
    - Security violations return BlufioError::Security and log at ERROR level
    - All tests pass with no clippy warnings
  </done>
</task>

<task type="auto" tdd="true">
  <name>Task 3: Implement plaintext config migration and vault startup integration</name>
  <files>
    crates/blufio-vault/src/migration.rs,
    crates/blufio-vault/src/lib.rs
  </files>
  <behavior>
    - Test 1: migrate_plaintext_secrets detects bot_token in TelegramConfig and migrates to vault
    - Test 2: migrate_plaintext_secrets detects api_key in AnthropicConfig and migrates to vault
    - Test 3: After migration, config file is rewritten without the plaintext secrets
    - Test 4: If vault write succeeds but config rewrite fails, function warns but does not error
    - Test 5: If secrets already exist in vault, migration is a no-op (idempotent)
    - Test 6: vault_startup_check returns Ok if no vault exists (first run, no secrets yet)
    - Test 7: vault_startup_check returns Err with clear message if vault exists but passphrase not provided
  </behavior>
  <action>
**Step 1: Create crates/blufio-vault/src/migration.rs.**

Auto-migration of plaintext secrets from TOML config to vault:

```rust
/// Check config for plaintext secrets and migrate them to the vault.
/// This is called on startup after vault is unlocked.
///
/// Per user decision: "Auto-migrate plaintext secrets found in TOML config
/// into vault on startup, remove from config file, warn user about migration"
pub fn migrate_plaintext_secrets(
    config: &BlufioConfig,
    config_path: &Path,
    vault: &Vault,
) -> Result<MigrationReport, BlufioError>
```

Implementation:
1. Scan config for known secret fields:
   - `config.telegram.bot_token` -- if Some, migrate as "telegram.bot_token"
   - `config.anthropic.api_key` -- if Some, migrate as "anthropic.api_key"
   (Future phases may add more secret fields)

2. For each detected plaintext secret:
   a. Check if already in vault (by name) -- skip if exists (idempotent)
   b. Store in vault via `vault.store_secret(name, value)`
   c. Log at WARN level: `"Migrating plaintext secret '{name}' from config to vault"`

3. After all secrets migrated to vault, rewrite config file:
   a. Read the original TOML file
   b. Parse as `toml::Value` (to preserve comments/formatting as much as possible -- note: toml crate doesn't preserve comments, but this is acceptable)
   c. Remove the migrated secret fields (set to None/remove key)
   d. Write back to config file

4. Error handling per user decision and research pitfall 6:
   - If vault write fails: return error (secret not safely stored)
   - If config rewrite fails: WARN but don't error. Secret is safely in vault. Plaintext copy will be caught again on next startup (idempotent).

5. Return `MigrationReport` with count of migrated secrets and any warnings.

```rust
pub struct MigrationReport {
    pub migrated: Vec<String>,  // names of secrets migrated
    pub skipped: Vec<String>,   // names already in vault
    pub warnings: Vec<String>,  // non-fatal issues (e.g., config rewrite failed)
}
```

**Step 2: Create vault startup integration helper.**

Add to vault module or lib.rs:

```rust
/// Check vault state and prepare for agent startup.
/// - If no vault exists: return Ok(None) -- vault created lazily on first set-secret
/// - If vault exists and passphrase available: unlock and return Vault
/// - If vault exists but no passphrase: return clear error (agent cannot start)
///
/// Per user decision: "Agent fails to start with clear error if vault exists
/// but is not unlocked -- no degraded/partial operation"
pub async fn vault_startup_check(
    conn: &tokio_rusqlite::Connection,
    config: &VaultConfig,
) -> Result<Option<Vault>, BlufioError>
```

Implementation:
1. Check if vault exists (via `Vault::exists(conn)`)
2. If vault does not exist: return `Ok(None)` -- vault is created lazily per user decision
3. If vault exists: call `prompt::get_vault_passphrase()`
4. If passphrase obtained: call `Vault::unlock(conn, passphrase, config)` and return `Ok(Some(vault))`
5. If passphrase unavailable: return `Err(BlufioError::Vault("Vault exists but no passphrase provided..."))`

**Step 3: Write tests.**

Migration tests need:
- A temp directory with a TOML config file containing plaintext secrets
- A SQLite database with vault tables (use `Database::open` from blufio-storage, or create tables manually)
- Verify secrets end up in vault after migration
- Verify config file is rewritten without secrets
- Test idempotency (running migration twice doesn't duplicate)

Startup check tests:
- No vault exists -> Ok(None)
- Vault exists + env var set -> Ok(Some(vault))
- Vault exists + no env var + not terminal -> Err with clear message

For testing the env var path: use `std::env::set_var` / `remove_var` in tests (with test serialization since env vars are process-global).

IMPORTANT: SPDX header on all files. Follow existing project patterns for error handling (BlufioError variants, tracing for logging).
  </action>
  <verify>
    <automated>cd /Users/suman/projects/github/blufio && cargo test -p blufio-vault -- --nocapture 2>&1 && cargo test --workspace 2>&1 && cargo clippy --workspace -- -D warnings 2>&1 | tail -20</automated>
  </verify>
  <done>
    - Plaintext secrets in config are detected and migrated to vault on startup
    - Config file is rewritten without plaintext secrets after migration
    - Migration is idempotent -- already-migrated secrets are skipped
    - Config rewrite failure is a warning, not an error (vault write succeeded)
    - vault_startup_check returns Ok(None) for first-run (no vault yet)
    - vault_startup_check fails with clear message if vault exists but unlockable
    - Full workspace builds, all tests pass, no clippy warnings
    - All new .rs files have SPDX license header
  </done>
</task>

<task type="auto" tdd="true">
  <name>Task 4: Wire vault CLI commands into blufio binary (set-secret, list-secrets)</name>
  <files>
    crates/blufio/Cargo.toml,
    crates/blufio/src/main.rs
  </files>
  <behavior>
    - Test 1: `blufio config set-secret my-key` with BLUFIO_VAULT_KEY env var prompts for value and stores encrypted secret in vault
    - Test 2: `blufio config list-secrets` displays stored secret names with masked previews (e.g., "sk-...4f2b")
    - Test 3: `blufio config list-secrets` with no vault shows empty list or informative message
    - Test 4: `blufio config set-secret` without key name prints usage error
    - Test 5: Setting a secret that already exists updates (overwrites) the existing entry
  </behavior>
  <action>
**Step 1: Add blufio-vault and blufio-storage dependencies to crates/blufio/Cargo.toml.**

Add to `[dependencies]`:
```toml
blufio-vault = { path = "../blufio-vault" }
blufio-storage = { path = "../blufio-storage" }
rpassword.workspace = true
```

`blufio-vault` is needed for Vault operations. `blufio-storage` is needed to open the database for vault table access. `rpassword` is needed for hidden secret value input.

**Step 2: Extend the CLI subcommand structure in crates/blufio/src/main.rs.**

Add nested subcommands to the existing `Config` variant:

```rust
#[derive(Subcommand, Debug)]
enum Commands {
    /// Start the Blufio agent server.
    Serve,
    /// Launch an interactive REPL session.
    Shell,
    /// Manage Blufio configuration.
    Config {
        #[command(subcommand)]
        action: Option<ConfigCommands>,
    },
}

#[derive(Subcommand, Debug)]
enum ConfigCommands {
    /// Store or update an encrypted secret in the vault.
    SetSecret {
        /// The name/key for the secret (e.g., "anthropic.api_key").
        key: String,
    },
    /// List all secrets stored in the vault (names and masked previews only).
    ListSecrets,
}
```

**Step 3: Implement the set-secret handler.**

In the `Commands::Config` match arm:

```rust
Some(Commands::Config { action }) => match action {
    Some(ConfigCommands::SetSecret { key }) => {
        // 1. Open the database at config.storage.database_path
        //    (reuse Database::open from blufio-storage)
        // 2. Get vault passphrase via blufio_vault::get_vault_passphrase()
        // 3. If vault exists: unlock it. If not: create it (lazy creation per user decision)
        // 4. Prompt for the secret value:
        //    - If stdin is a TTY: use rpassword::read_password() with "Secret value: " prompt
        //    - If stdin is piped: read a line from stdin (for scripting support)
        // 5. Call vault.store_secret(&key, &value)
        // 6. Print confirmation: "Secret '{key}' stored in vault."
        // 7. Close database (WAL checkpoint)
    },
    Some(ConfigCommands::ListSecrets) => {
        // 1. Open the database at config.storage.database_path
        // 2. Check if vault exists. If not: print "No vault found. Use 'blufio config set-secret' to create one." and exit cleanly.
        // 3. Get vault passphrase and unlock vault
        // 4. Call vault.list_secrets()
        // 5. For each (name, masked_preview): print "{name}: {masked_preview}"
        // 6. If empty: print "No secrets stored."
        // 7. Close database
    },
    None => {
        println!("blufio config: use --help for available config commands");
    }
}
```

Key implementation notes:
- Vault is created lazily on first `set-secret` call per CONTEXT.md locked decision
- Secret value prompt uses hidden input (no echo) on TTY, stdin pipe for scripting -- per locked decision: "Hidden prompt (no echo) for interactive use, stdin pipe support for scripting -- TTY detection selects mode automatically"
- list-secrets shows masked preview per locked decision: "`blufio config list-secrets` shows names + masked preview -- values never fully displayed"
- Both commands open the database, perform vault operation, then close (clean WAL checkpoint)
- Error messages should be user-friendly (not raw BlufioError debug output)

**Step 4: Write tests.**

Integration tests for CLI commands:
- Test set-secret: Set BLUFIO_VAULT_KEY env var, pipe secret value via stdin, verify vault entry created in temp database
- Test list-secrets: After storing a secret, run list-secrets and verify output contains masked preview
- Test no vault: Run list-secrets with no prior vault, verify informative message
- Test missing key name: Verify clap rejects `blufio config set-secret` without a key argument

NOTE: Full CLI integration tests may use `assert_cmd` or `std::process::Command`. Alternatively, extract the command handlers into functions and unit test those directly. The simpler approach (unit testing handler functions) is preferred -- don't add `assert_cmd` as a dependency unless it's already in the workspace.

IMPORTANT: SPDX header on all modified files. Preserve existing code structure and patterns in main.rs.
  </action>
  <verify>
    <automated>cd /Users/suman/projects/github/blufio && cargo build -p blufio 2>&1 && cargo test -p blufio 2>&1 && cargo test --workspace 2>&1 && cargo clippy --workspace -- -D warnings 2>&1 | tail -20</automated>
  </verify>
  <done>
    - `blufio config set-secret <key>` creates vault lazily and stores encrypted secret
    - `blufio config list-secrets` shows secret names with masked previews
    - Secret value input uses hidden prompt on TTY, stdin pipe for scripting
    - No vault scenario handled gracefully with informative message
    - Missing key argument rejected by clap with usage help
    - blufio binary crate compiles with vault and storage dependencies
    - All workspace tests pass, no clippy warnings
    - SPDX license header preserved in modified files
  </done>
</task>

</tasks>

<verification>
After all tasks complete, verify the phase requirements:

1. **SEC-01 (Localhost binding):** SecurityConfig.bind_address defaults to "127.0.0.1" (config default established in Phase 1, is_localhost() utility created in Phase 2). Runtime binding enforcement is verified in Phase 3 when `blufio serve` is implemented.
2. **SEC-03 (AES-256-GCM vault):** `cargo test -p blufio-vault` demonstrates seal/open round-trip with ring::aead::AES_256_GCM
3. **SEC-04 (Argon2id, never on disk):** KDF derives key in memory only, wrapped by SecretBox/Zeroizing, master key stored only as wrapped ciphertext in vault_meta
4. **SEC-08 (Secret redaction):** RedactingWriter catches regex patterns + exact vault values, replacing with [REDACTED]
5. **SEC-09 (SSRF prevention):** SsrfSafeResolver blocks all RFC 1918/4193/link-local ranges, respects allowlist
6. **SEC-10 (TLS required):** build_secure_client enforces TLS 1.2+, validate_url blocks non-TLS remote URLs
7. **CLI (Locked user decision):** `blufio config set-secret <key>` and `blufio config list-secrets` subcommands work end-to-end, wiring CLI dispatch to vault library functions

```bash
cd /Users/suman/projects/github/blufio && cargo test --workspace 2>&1 && cargo clippy --workspace -- -D warnings 2>&1 && cargo deny check 2>&1
```
</verification>

<success_criteria>
- blufio-vault crate: AES-256-GCM encryption, Argon2id KDF, key wrapping, vault CRUD, passphrase prompt
- blufio-security crate: TLS enforcement, SSRF prevention, secret redaction
- Vault key derived from passphrase via Argon2id, never stored on disk
- Key wrapping: changing passphrase re-wraps master key without re-encrypting secrets
- Plaintext config secrets auto-migrated to vault on startup
- vault_startup_check returns clear error if vault exists but passphrase not provided
- Localhost exempt from TLS, all remote connections require TLS 1.2+
- Private IP ranges blocked by default with configurable allowlist
- Secrets redacted from logs via regex patterns + exact vault value matching
- Security utility functions return BlufioError::Security and log at ERROR level on violations
- `blufio config set-secret <key>` CLI command stores encrypted secrets via vault
- `blufio config list-secrets` CLI command displays names + masked previews, values never fully shown
- All files have SPDX license headers, no clippy warnings, cargo deny passes
</success_criteria>

<output>
After completion, create `.planning/phases/02-persistence-security-vault/02-02-SUMMARY.md`
</output>
