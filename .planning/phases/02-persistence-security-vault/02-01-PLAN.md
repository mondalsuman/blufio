---
phase: 02-persistence-security-vault
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - Cargo.toml
  - crates/blufio-core/src/error.rs
  - crates/blufio-config/src/model.rs
  - crates/blufio-config/src/validation.rs
  - crates/blufio-storage/Cargo.toml
  - crates/blufio-storage/src/lib.rs
  - crates/blufio-storage/src/database.rs
  - crates/blufio-storage/src/writer.rs
  - crates/blufio-storage/src/models.rs
  - crates/blufio-storage/src/queries/mod.rs
  - crates/blufio-storage/src/queries/sessions.rs
  - crates/blufio-storage/src/queries/messages.rs
  - crates/blufio-storage/src/queries/queue.rs
  - crates/blufio-storage/src/migrations.rs
  - crates/blufio-storage/migrations/V1__initial_schema.sql
autonomous: true
requirements:
  - PERS-01
  - PERS-02
  - PERS-03
  - PERS-04
  - PERS-05

must_haves:
  truths:
    - "SQLite database opens in WAL mode with ACID guarantees on first startup"
    - "Sessions, messages, and queue entries persist across process restarts with zero data loss"
    - "All database writes are serialized through a single writer thread -- zero SQLITE_BUSY errors under concurrent access"
    - "cp blufio.db blufio.db.bak creates a complete backup after clean shutdown (WAL checkpoint on close)"
    - "Database file and parent directories are created automatically on first startup at XDG data path"
    - "Embedded migrations run automatically on startup with schema version tracking"
  artifacts:
    - path: "crates/blufio-storage/src/lib.rs"
      provides: "Public API for storage crate"
      min_lines: 20
    - path: "crates/blufio-storage/src/database.rs"
      provides: "Database connection management with PRAGMA setup"
      contains: "journal_mode = WAL"
    - path: "crates/blufio-storage/src/writer.rs"
      provides: "Single-writer wrapper around tokio-rusqlite"
      contains: "tokio_rusqlite::Connection"
    - path: "crates/blufio-storage/src/queries/sessions.rs"
      provides: "Session CRUD operations"
      exports: ["create_session", "get_session", "list_sessions", "update_session_state"]
    - path: "crates/blufio-storage/src/queries/messages.rs"
      provides: "Message CRUD operations"
      exports: ["insert_message", "get_messages_for_session"]
    - path: "crates/blufio-storage/src/queries/queue.rs"
      provides: "Queue operations for crash-safe message processing"
      exports: ["enqueue", "dequeue", "ack", "fail"]
    - path: "crates/blufio-storage/migrations/V1__initial_schema.sql"
      provides: "Initial database schema"
      contains: "CREATE TABLE"
  key_links:
    - from: "crates/blufio-storage/src/database.rs"
      to: "crates/blufio-storage/migrations/"
      via: "refinery embed_migrations! auto-run on open"
      pattern: "embed_migrations!"
    - from: "crates/blufio-storage/src/writer.rs"
      to: "tokio-rusqlite single background thread"
      via: "Connection::open + conn.call() for all writes"
      pattern: "conn\\.call"
    - from: "crates/blufio-storage/src/database.rs"
      to: "WAL checkpoint on close"
      via: "PRAGMA wal_checkpoint(TRUNCATE) in close()"
      pattern: "wal_checkpoint"
---

<objective>
Create the blufio-storage crate implementing SQLite persistence with WAL mode, embedded migrations, single-writer concurrency, and CRUD operations for sessions, messages, and a crash-safe message queue.

Purpose: All application state must persist in a single SQLite database with ACID guarantees. This is the persistence foundation that every subsequent phase depends on -- the credential vault (Plan 02) stores encrypted entries here, the agent loop (Phase 3) persists conversations here, and the memory system (Phase 5) stores embeddings here.

Output: A fully functional `blufio-storage` crate with database lifecycle management, automatic migrations, and typed query modules for sessions, messages, and queue operations.
</objective>

<execution_context>
@/Users/suman/.claude/get-shit-done/workflows/execute-plan.md
@/Users/suman/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-persistence-security-vault/02-RESEARCH.md
@.planning/phases/02-persistence-security-vault/02-CONTEXT.md
@.planning/phases/01-project-foundation-workspace/01-01-SUMMARY.md
@.planning/phases/01-project-foundation-workspace/01-02-SUMMARY.md

<interfaces>
<!-- Key types and contracts the executor needs. Extracted from codebase. -->

From crates/blufio-core/src/traits/storage.rs:
```rust
#[async_trait]
pub trait StorageAdapter: PluginAdapter {
    async fn initialize(&self) -> Result<(), BlufioError>;
    async fn close(&self) -> Result<(), BlufioError>;
}
```

From crates/blufio-core/src/traits/adapter.rs:
```rust
#[async_trait]
pub trait PluginAdapter: Send + Sync + 'static {
    fn name(&self) -> &str;
    fn version(&self) -> semver::Version;
    fn adapter_type(&self) -> AdapterType;
    async fn health_check(&self) -> Result<HealthStatus, BlufioError>;
    async fn shutdown(&self) -> Result<(), BlufioError>;
}
```

From crates/blufio-core/src/error.rs:
```rust
#[derive(Debug, Error)]
pub enum BlufioError {
    #[error("storage error: {source}")]
    Storage { source: Box<dyn std::error::Error + Send + Sync> },
    // ... other variants
}
```

From crates/blufio-config/src/model.rs:
```rust
#[derive(Debug, Clone, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct StorageConfig {
    #[serde(default = "default_database_path")]
    pub database_path: String,
    #[serde(default = "default_wal_mode")]
    pub wal_mode: bool,
}

#[derive(Debug, Clone, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct SecurityConfig {
    #[serde(default = "default_bind_address")]
    pub bind_address: String,
    #[serde(default = "default_require_tls")]
    pub require_tls: bool,
}
```

From Cargo.toml workspace dependencies:
```toml
[workspace.dependencies]
serde = { version = "1", features = ["derive"] }
thiserror = "2"
async-trait = "0.1"
tokio = { version = "1" }
dirs = "6"
tracing = "0.1"
```
</interfaces>
</context>

<tasks>

<task type="auto" tdd="true">
  <name>Task 1: Scaffold blufio-storage crate with workspace dependencies, config extensions, and error variants</name>
  <files>
    Cargo.toml,
    crates/blufio-storage/Cargo.toml,
    crates/blufio-storage/src/lib.rs,
    crates/blufio-storage/src/models.rs,
    crates/blufio-core/src/error.rs,
    crates/blufio-config/src/model.rs,
    crates/blufio-config/src/validation.rs
  </files>
  <behavior>
    - Test 1: blufio-storage crate compiles and is part of the workspace
    - Test 2: StorageConfig.database_path defaults to XDG data dir path (not bare "blufio.db")
    - Test 3: SecurityConfig has allowed_private_ips field that defaults to empty Vec
    - Test 4: BlufioError has Vault and Security variants
    - Test 5: Model types (Session, Message, QueueEntry) are defined with correct fields and derive Debug, Clone, Serialize, Deserialize
  </behavior>
  <action>
**Step 1: Add workspace dependencies to root Cargo.toml.**

Add to `[workspace.dependencies]`:
```toml
rusqlite = { version = "0.33", features = ["bundled"] }
tokio-rusqlite = "0.6"
refinery = { version = "0.9", features = ["rusqlite"] }
ring = "0.17"
argon2 = "0.5"
secrecy = { version = "0.10", features = ["serde"] }
rpassword = "7"
zeroize = { version = "1.8", features = ["derive"] }
rand = "0.8"
regex = "1"
reqwest = { version = "0.12", features = ["json", "rustls-tls"], default-features = false }
```

NOTE: Use rusqlite 0.33 (not 0.38 from research -- 0.33 is the latest stable on crates.io as of 2026-02). Verify with `cargo search rusqlite` before adding. If 0.38 exists, use it. The research may have been forward-looking. tokio-rusqlite 0.6 depends on rusqlite, so their versions must be compatible -- check tokio-rusqlite's Cargo.toml deps.

**Step 2: Create crates/blufio-storage/Cargo.toml.**

```toml
[package]
name = "blufio-storage"
version.workspace = true
edition.workspace = true
license.workspace = true
repository.workspace = true
authors.workspace = true
publish = false
description = "SQLite persistence layer for the Blufio agent framework"

[dependencies]
blufio-core.path = "../blufio-core"
blufio-config.path = "../blufio-config"
rusqlite.workspace = true
tokio-rusqlite.workspace = true
refinery.workspace = true
serde.workspace = true
serde_json = "1"
async-trait.workspace = true
tokio.workspace = true
tracing.workspace = true
dirs.workspace = true
semver.workspace = true
thiserror.workspace = true

[dev-dependencies]
tokio = { workspace = true, features = ["macros", "rt-multi-thread"] }
tempfile = "3"
```

**Step 3: Create crates/blufio-storage/src/models.rs.**

Define row types matching the SQL schema from research:
- `Session` struct: id (String), channel (String), user_id (Option<String>), state (String, default "active"), metadata (Option<String> for JSON), created_at (String, ISO 8601), updated_at (String)
- `Message` struct: id (String), session_id (String), role (String -- "user"/"assistant"/"system"/"tool"), content (String), token_count (Option<i64>), metadata (Option<String>), created_at (String)
- `QueueEntry` struct: id (i64), queue_name (String), payload (String -- JSON), status (String -- "pending"/"processing"/"completed"/"failed"), attempts (i32), max_attempts (i32), created_at (String), updated_at (String), locked_until (Option<String>)

All types derive: `Debug, Clone, Serialize, Deserialize`. Add SPDX header.

**Step 4: Create crates/blufio-storage/src/lib.rs.**

Public module declarations: `pub mod database;`, `pub mod writer;`, `pub mod models;`, `pub mod queries;`, `pub mod migrations;`. Re-export key types: `pub use database::Database;`, `pub use models::*;`. Add SPDX header.

**Step 5: Extend BlufioError in crates/blufio-core/src/error.rs.**

Add two new variants:
```rust
/// Credential vault errors (decryption failure, vault locked, key derivation).
#[error("vault error: {0}")]
Vault(String),

/// Security policy violations (TLS required, SSRF blocked, invalid credential).
#[error("security violation: {0}")]
Security(String),
```

**Step 6: Update StorageConfig in crates/blufio-config/src/model.rs.**

Change `default_database_path()` to use XDG data directory:
```rust
fn default_database_path() -> String {
    dirs::data_dir()
        .map(|p| p.join("blufio").join("blufio.db"))
        .unwrap_or_else(|| std::path::PathBuf::from("blufio.db"))
        .to_string_lossy()
        .into_owned()
}
```

**Step 7: Extend SecurityConfig in crates/blufio-config/src/model.rs.**

Add `allowed_private_ips` field:
```rust
pub struct SecurityConfig {
    #[serde(default = "default_bind_address")]
    pub bind_address: String,
    #[serde(default = "default_require_tls")]
    pub require_tls: bool,
    /// Private IP addresses allowed for SSRF exemption (e.g., local services).
    #[serde(default)]
    pub allowed_private_ips: Vec<String>,
}
```
Update the `Default` impl to include `allowed_private_ips: vec![]`.

**Step 8: Add VaultConfig section to BlufioConfig.**

Add to BlufioConfig struct:
```rust
/// Credential vault settings.
#[serde(default)]
pub vault: VaultConfig,
```

Create VaultConfig struct:
```rust
/// Credential vault configuration.
#[derive(Debug, Clone, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct VaultConfig {
    /// Argon2id memory cost in KiB (default: 65536 = 64 MiB).
    #[serde(default = "default_kdf_memory_cost")]
    pub kdf_memory_cost: u32,
    /// Argon2id iteration count (default: 3).
    #[serde(default = "default_kdf_iterations")]
    pub kdf_iterations: u32,
    /// Argon2id parallelism lanes (default: 4).
    #[serde(default = "default_kdf_parallelism")]
    pub kdf_parallelism: u32,
}
```
Defaults: `kdf_memory_cost=65536`, `kdf_iterations=3`, `kdf_parallelism=4` per OWASP recommendations from research.
Follow existing pattern: `deny_unknown_fields`, `Default` impl with named default functions.

**Step 9: Update post-deserialization validation** in crates/blufio-config/src/validation.rs if it exists, or the validation logic in the config crate. Add validation:
- `kdf_memory_cost >= 32768` (minimum safe value per research pitfall 4)
- `kdf_iterations >= 2`
- `kdf_parallelism >= 1`
- `bind_address` is a valid IP address

IMPORTANT: All config structs MUST use `#[serde(deny_unknown_fields)]` -- this is a locked pattern from Phase 1.
  </action>
  <verify>
    <automated>cd /Users/suman/projects/github/blufio && cargo build 2>&1 && cargo test -p blufio-storage 2>&1 && cargo test -p blufio-config 2>&1</automated>
  </verify>
  <done>
    - blufio-storage crate exists in workspace and compiles cleanly
    - Model types (Session, Message, QueueEntry) are defined with all required fields
    - StorageConfig.database_path defaults to XDG data directory path
    - SecurityConfig.allowed_private_ips field exists, defaults to empty Vec
    - VaultConfig exists with Argon2id parameter fields and OWASP-safe defaults
    - BlufioError has Vault and Security variants
    - All new config structs use deny_unknown_fields
    - cargo build succeeds across entire workspace
  </done>
</task>

<task type="auto" tdd="true">
  <name>Task 2: Implement database connection, migrations, single-writer, and query modules</name>
  <files>
    crates/blufio-storage/src/database.rs,
    crates/blufio-storage/src/writer.rs,
    crates/blufio-storage/src/migrations.rs,
    crates/blufio-storage/src/queries/mod.rs,
    crates/blufio-storage/src/queries/sessions.rs,
    crates/blufio-storage/src/queries/messages.rs,
    crates/blufio-storage/src/queries/queue.rs,
    crates/blufio-storage/migrations/V1__initial_schema.sql
  </files>
  <behavior>
    - Test 1: Database::open creates DB file and parent directories if they don't exist
    - Test 2: Database::open applies WAL mode and recommended PRAGMAs (journal_mode=WAL, synchronous=NORMAL, foreign_keys=ON, busy_timeout=5000, cache_size=-16000, temp_store=MEMORY)
    - Test 3: Migrations run automatically on open -- sessions, messages, queue, vault_entries, vault_meta tables exist
    - Test 4: create_session + get_session round-trips correctly
    - Test 5: insert_message + get_messages_for_session returns messages in chronological order
    - Test 6: enqueue + dequeue returns next pending entry and marks it processing
    - Test 7: ack removes completed entry, fail increments attempts and resets to pending (or failed if max_attempts reached)
    - Test 8: Database::close runs WAL checkpoint (TRUNCATE) -- after close, no -wal file should exist
    - Test 9: Multiple concurrent async tasks writing through the single writer produce no SQLITE_BUSY errors
  </behavior>
  <action>
**Step 1: Create migrations/V1__initial_schema.sql.**

Use the schema from the research section verbatim (sessions, messages, queue, vault_entries, vault_meta tables with all indexes). This is the single migration file -- vault tables are included here because they live in the same database (per research recommendation and PERS-04 single-file backup requirement).

**Step 2: Create crates/blufio-storage/src/migrations.rs.**

Use refinery's `embed_migrations!` macro to compile SQL migrations into the binary:
```rust
mod embedded {
    use refinery::embed_migrations;
    embed_migrations!("migrations");
}

pub fn run_migrations(conn: &mut rusqlite::Connection) -> Result<(), BlufioError> {
    embedded::migrations::runner().run(conn).map_err(|e| {
        BlufioError::Storage { source: Box::new(e) }
    })?;
    Ok(())
}
```

NOTE: refinery tracks schema versions in its own `refinery_schema_history` table (not `_migrations` as CONTEXT.md mentioned). This is correct behavior -- refinery manages its own tracking.

**Step 3: Create crates/blufio-storage/src/database.rs.**

The `Database` struct wraps a `tokio_rusqlite::Connection` and provides the lifecycle:

```rust
pub struct Database {
    conn: tokio_rusqlite::Connection,
}
```

`Database::open(path: &str)` must:
1. Create parent directories if they don't exist (`std::fs::create_dir_all`)
2. Open connection via `tokio_rusqlite::Connection::open(path)`
3. Apply PRAGMAs on the background thread via `conn.call()`:
   - `PRAGMA journal_mode = WAL;` (MUST be first, outside transaction)
   - `PRAGMA synchronous = NORMAL;`
   - `PRAGMA busy_timeout = 5000;`
   - `PRAGMA foreign_keys = ON;`
   - `PRAGMA cache_size = -16000;`
   - `PRAGMA temp_store = MEMORY;`
4. Run migrations via `conn.call(|conn| migrations::run_migrations(conn))`
5. Return `Database { conn }`

`Database::close(&self)` must:
1. Run `PRAGMA wal_checkpoint(TRUNCATE)` via `conn.call()` to merge WAL into main file
2. Call `conn.close().await` (or let it drop -- check tokio-rusqlite API)

This satisfies PERS-04: after close, `blufio.db` is self-contained for `cp` backup.

Expose `conn` via a method like `connection(&self) -> &tokio_rusqlite::Connection` for query modules to use, or pass the connection into query functions.

**Step 4: Create crates/blufio-storage/src/writer.rs.**

This module documents and enforces the single-writer pattern. Since `tokio-rusqlite` already uses a single background thread, the writer module can either:
- Be a thin wrapper re-exporting the `Database` with documentation explaining the pattern
- OR provide typed write operations that go through the single connection

Recommended: Make `Database` the single writer directly. All query modules accept `&Database` and call through `conn.call()`. Document clearly: "All writes are serialized through tokio-rusqlite's single background thread. Do NOT create additional Connection instances for writes."

**Step 5: Create query modules.**

All query functions take `&Database` (or `&tokio_rusqlite::Connection`) and return `Result<T, BlufioError>`.

`queries/sessions.rs`:
- `create_session(db, session: &Session) -> Result<(), BlufioError>` -- INSERT into sessions table
- `get_session(db, id: &str) -> Result<Option<Session>, BlufioError>` -- SELECT by id
- `list_sessions(db, state: Option<&str>) -> Result<Vec<Session>, BlufioError>` -- SELECT with optional state filter
- `update_session_state(db, id: &str, state: &str) -> Result<(), BlufioError>` -- UPDATE state + updated_at

`queries/messages.rs`:
- `insert_message(db, msg: &Message) -> Result<(), BlufioError>` -- INSERT into messages table
- `get_messages_for_session(db, session_id: &str, limit: Option<i64>) -> Result<Vec<Message>, BlufioError>` -- SELECT by session_id ORDER BY created_at ASC with optional LIMIT

`queries/queue.rs`:
- `enqueue(db, queue_name: &str, payload: &str) -> Result<i64, BlufioError>` -- INSERT into queue, return id
- `dequeue(db, queue_name: &str) -> Result<Option<QueueEntry>, BlufioError>` -- SELECT oldest pending entry, UPDATE status to "processing" and locked_until to now+5min, return entry. Use a single atomic SQL statement (UPDATE ... RETURNING or two-statement transaction).
- `ack(db, id: i64) -> Result<(), BlufioError>` -- UPDATE status to "completed"
- `fail(db, id: i64) -> Result<(), BlufioError>` -- INCREMENT attempts. If attempts >= max_attempts, set status to "failed". Otherwise set status back to "pending" and clear locked_until.

Each query module uses `conn.call(move |conn| { ... })` pattern with `rusqlite::params![]`. Map rusqlite errors to `BlufioError::Storage`.

Use `rusqlite::Row` mapping (via closures in `query_row` / `query_map`) to convert rows into model types. Consider implementing `TryFrom<&rusqlite::Row>` for each model type for cleaner code.

**Step 6: Write tests.**

Create comprehensive tests in each module:
- `database.rs` tests: open creates file, PRAGMAs applied (query PRAGMA values back), migrations create tables (query sqlite_master), close checkpoints WAL
- `queries/*.rs` tests: CRUD round-trips for each entity type
- Integration test: spawn 10 concurrent tokio tasks all writing through the same Database instance, assert no SQLITE_BUSY errors and all writes succeed

Use `tempfile::tempdir()` for test database paths to avoid test pollution.

IMPORTANT: All `.rs` files must have SPDX dual-license header:
```rust
// SPDX-FileCopyrightText: 2026 Blufio Contributors
// SPDX-License-Identifier: MIT OR Apache-2.0
```
  </action>
  <verify>
    <automated>cd /Users/suman/projects/github/blufio && cargo test -p blufio-storage -- --nocapture 2>&1 && cargo test -p blufio-core 2>&1 && cargo build --release 2>&1 | tail -5</automated>
  </verify>
  <done>
    - Database::open creates file + parent dirs, applies WAL mode + all PRAGMAs, runs migrations
    - Sessions CRUD: create, get, list, update_state all work correctly
    - Messages CRUD: insert + get_for_session returns chronological order
    - Queue: enqueue/dequeue/ack/fail lifecycle works with atomic status transitions
    - Database::close runs WAL checkpoint -- no -wal file after close
    - 10 concurrent async writers produce zero SQLITE_BUSY errors
    - All tests pass, workspace compiles cleanly
    - All new .rs files have SPDX license header
  </done>
</task>

<task type="auto" tdd="true">
  <name>Task 3: Implement StorageAdapter trait and integrate with binary startup</name>
  <files>
    crates/blufio-storage/src/lib.rs,
    crates/blufio-storage/src/database.rs,
    crates/blufio-core/src/traits/storage.rs
  </files>
  <behavior>
    - Test 1: SqliteStorage implements StorageAdapter + PluginAdapter traits
    - Test 2: SqliteStorage::initialize() opens database at configured path with migrations
    - Test 3: SqliteStorage::close() checkpoints WAL and closes connection
    - Test 4: SqliteStorage::health_check() returns healthy when DB is open
    - Test 5: SqliteStorage reports name="sqlite", adapter_type=AdapterType::Storage
  </behavior>
  <action>
**Step 1: Extend StorageAdapter trait** in crates/blufio-core/src/traits/storage.rs.

Add query methods to StorageAdapter that the agent will use. These are generic -- the SQLite implementation is in blufio-storage. Keep the trait in blufio-core so it remains implementation-agnostic:

```rust
#[async_trait]
pub trait StorageAdapter: PluginAdapter {
    async fn initialize(&self) -> Result<(), BlufioError>;
    async fn close(&self) -> Result<(), BlufioError>;

    // Session operations
    async fn create_session(&self, session: &crate::types::Session) -> Result<(), BlufioError>;
    async fn get_session(&self, id: &str) -> Result<Option<crate::types::Session>, BlufioError>;
    async fn list_sessions(&self, state: Option<&str>) -> Result<Vec<crate::types::Session>, BlufioError>;
    async fn update_session_state(&self, id: &str, state: &str) -> Result<(), BlufioError>;

    // Message operations
    async fn insert_message(&self, message: &crate::types::Message) -> Result<(), BlufioError>;
    async fn get_messages(&self, session_id: &str, limit: Option<i64>) -> Result<Vec<crate::types::Message>, BlufioError>;

    // Queue operations
    async fn enqueue(&self, queue_name: &str, payload: &str) -> Result<i64, BlufioError>;
    async fn dequeue(&self, queue_name: &str) -> Result<Option<crate::types::QueueEntry>, BlufioError>;
    async fn ack(&self, id: i64) -> Result<(), BlufioError>;
    async fn fail(&self, id: i64) -> Result<(), BlufioError>;
}
```

WAIT: The Session/Message/QueueEntry types are currently in blufio-storage, but the trait is in blufio-core which cannot depend on blufio-storage (circular dependency). Two options:
- Option A: Move model types to blufio-core (preferred -- they're shared domain types)
- Option B: Keep trait methods accepting raw primitives

Choose Option A: Move Session, Message, QueueEntry to `blufio-core/src/types.rs` (or a new `blufio-core/src/types/models.rs`). blufio-storage then imports them from blufio-core. This keeps the trait fully typed.

Check what's currently in `blufio-core/src/types.rs` and add the model types there. In blufio-storage/src/models.rs, re-export from blufio-core instead of defining locally.

**Step 2: Create SqliteStorage struct** in crates/blufio-storage/src/lib.rs (or a dedicated adapter.rs module).

```rust
pub struct SqliteStorage {
    config: blufio_config::model::StorageConfig,
    db: tokio::sync::OnceCell<Database>,
}

impl SqliteStorage {
    pub fn new(config: blufio_config::model::StorageConfig) -> Self {
        Self { config, db: tokio::sync::OnceCell::new() }
    }

    fn db(&self) -> Result<&Database, BlufioError> {
        self.db.get().ok_or_else(|| BlufioError::Storage {
            source: "storage not initialized".into()
        })
    }
}
```

**Step 3: Implement PluginAdapter for SqliteStorage.**
- `name()` -> `"sqlite"`
- `version()` -> `semver::Version::new(0, 1, 0)`
- `adapter_type()` -> `AdapterType::Storage`
- `health_check()` -> Query `SELECT 1` via the connection. If it succeeds, return `HealthStatus::Healthy`.
- `shutdown()` -> Delegate to `close()`

**Step 4: Implement StorageAdapter for SqliteStorage.**
- `initialize()` -> Call `Database::open(&self.config.database_path)` and store in `OnceCell`
- `close()` -> Call `self.db().close()`, checkpoint WAL
- All query methods delegate to the corresponding functions in `queries::*` modules

**Step 5: Write tests** verifying the full adapter lifecycle:
- Create SqliteStorage with tempdir path
- Call initialize() -> DB file created
- Create a session, insert messages, verify retrieval
- Call close() -> WAL checkpointed
- health_check returns healthy while open

IMPORTANT: All `.rs` files must have SPDX dual-license header.
  </action>
  <verify>
    <automated>cd /Users/suman/projects/github/blufio && cargo test --workspace 2>&1 && cargo clippy --workspace -- -D warnings 2>&1 | tail -20</automated>
  </verify>
  <done>
    - SqliteStorage implements both StorageAdapter and PluginAdapter traits
    - Model types (Session, Message, QueueEntry) live in blufio-core for trait compatibility
    - initialize() opens database with migrations, close() checkpoints WAL
    - health_check() verifies database connectivity
    - All trait methods delegate to query modules correctly
    - Full workspace builds and all tests pass with no clippy warnings
    - All new .rs files have SPDX license header
  </done>
</task>

</tasks>

<verification>
After all tasks complete, verify the phase requirements:

1. **PERS-01 (WAL + ACID):** `cargo test -p blufio-storage` includes a test that opens DB and queries `PRAGMA journal_mode` returning "wal"
2. **PERS-02 (Session persistence):** Test creates session, closes DB, reopens at same path, retrieves session successfully
3. **PERS-03 (Crash-safe queue):** Test enqueues item, verifies it survives close+reopen cycle
4. **PERS-04 (cp backup):** Test opens DB, writes data, closes (WAL checkpoint), verifies no `-wal` file exists, copies DB file, opens copy and verifies data integrity
5. **PERS-05 (No SQLITE_BUSY):** Test spawns 10+ concurrent writers through single Database instance, all succeed without SQLITE_BUSY

```bash
cd /Users/suman/projects/github/blufio && cargo test --workspace 2>&1 && cargo clippy --workspace -- -D warnings 2>&1 && cargo deny check 2>&1
```
</verification>

<success_criteria>
- blufio-storage crate compiles, tests pass, integrates with workspace
- SQLite database with WAL mode, ACID transactions, recommended PRAGMAs
- Embedded migrations auto-apply on startup with schema version tracking
- Session/Message/Queue CRUD operations fully functional
- Single-writer pattern enforced (zero SQLITE_BUSY under concurrent access)
- WAL checkpoint on close enables single-file cp backup
- StorageAdapter trait extended with typed query methods
- SqliteStorage implements full StorageAdapter + PluginAdapter
- Config extended with VaultConfig, SecurityConfig.allowed_private_ips, XDG default database path
- BlufioError extended with Vault and Security variants
- All files have SPDX license headers, no clippy warnings
</success_criteria>

<output>
After completion, create `.planning/phases/02-persistence-security-vault/02-01-SUMMARY.md`
</output>
