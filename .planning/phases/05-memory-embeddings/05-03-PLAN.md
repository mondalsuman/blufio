---
phase: 05-memory-embeddings
plan: 03
type: execute
wave: 3
depends_on: [05-02]
files_modified:
  - crates/blufio-agent/src/session.rs
  - crates/blufio-agent/src/context.rs
  - crates/blufio-agent/src/lib.rs
  - crates/blufio-agent/Cargo.toml
  - crates/blufio/src/main.rs
  - crates/blufio/Cargo.toml
autonomous: true
requirements:
  - MEM-01
  - MEM-03

must_haves:
  truths:
    - MemoryProvider is registered with ContextEngine as a ConditionalProvider at startup
    - SessionActor sets the current user message on MemoryProvider before context assembly
    - Memory extraction triggers when a session goes idle for 5+ minutes
    - Extraction Haiku calls are recorded in the cost ledger with FeatureType::Extraction
    - Explicit "remember this" commands trigger immediate memory extraction
    - Explicit "forget that X" commands trigger memory search and soft-delete
    - Agent uses memories naturally in responses without calling them out
    - Model auto-downloads on first startup if not cached
  artifacts:
    - crates/blufio-agent/src/session.rs (modified)
    - crates/blufio-agent/src/context.rs (modified)
  key_links:
    - MemoryProvider registered via ContextEngine::add_conditional_provider()
    - MemoryExtractor called by SessionActor when idle timeout fires
    - Extraction cost recorded via CostLedger with FeatureType::Extraction
    - ModelManager::ensure_model called at startup to download if needed
---

<objective>
Wire the memory system into the agent loop: register MemoryProvider with ContextEngine, trigger extraction on idle sessions, handle explicit remember/forget commands, record extraction costs, and auto-download the embedding model on first startup.

Purpose: This is the integration plan that makes the memory system live. Plans 01 and 02 built the components; this plan connects them to the running agent so memories are actually created, stored, retrieved, and surfaced to users.

Output: Updated session actor with memory extraction triggers, context engine with memory provider, startup with model download, cost tracking for extraction calls.
</objective>

<execution_context>
@/Users/suman/.claude/get-shit-done/workflows/execute-plan.md
@/Users/suman/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/STATE.md
@.planning/ROADMAP.md
@.planning/phases/05-memory-embeddings/05-CONTEXT.md
@.planning/phases/05-memory-embeddings/05-RESEARCH.md
@.planning/phases/05-memory-embeddings/05-01-SUMMARY.md
@.planning/phases/05-memory-embeddings/05-02-SUMMARY.md

@crates/blufio-agent/src/session.rs
@crates/blufio-agent/src/context.rs
@crates/blufio-agent/src/lib.rs
@crates/blufio-agent/Cargo.toml
@crates/blufio/src/main.rs
@crates/blufio/Cargo.toml
@crates/blufio-context/src/lib.rs
@crates/blufio-cost/src/ledger.rs

<interfaces>
<!-- Key types from Plans 01 and 02 -->

From crates/blufio-memory (created in Plans 01-02):
```rust
// From lib.rs:
pub use embedder::OnnxEmbedder;
pub use model_manager::ModelManager;
pub use store::MemoryStore;
pub use retriever::HybridRetriever;
pub use extractor::MemoryExtractor;
pub use provider::MemoryProvider;

// MemoryProvider methods:
impl MemoryProvider {
    pub fn new(retriever: Arc<HybridRetriever>) -> Self;
    pub async fn set_current_query(&self, session_id: &str, query: &str);
    pub async fn clear_current_query(&self, session_id: &str);
}

// MemoryExtractor methods:
impl MemoryExtractor {
    pub async fn extract_from_conversation(&self, provider: &dyn ProviderAdapter, session_id: &str, conversation: &[ProviderMessage]) -> Result<Vec<Memory>, BlufioError>;
    pub async fn extract_explicit(&self, text: &str, session_id: &str) -> Result<Memory, BlufioError>;
}

// ModelManager methods:
impl ModelManager {
    pub fn new(data_dir: PathBuf) -> Self;
    pub async fn ensure_model(&self) -> Result<PathBuf, BlufioError>;
    pub fn is_model_available(&self) -> bool;
}
```

From crates/blufio-context/src/lib.rs:
```rust
impl ContextEngine {
    pub fn add_conditional_provider(&mut self, provider: Box<dyn ConditionalProvider>);
}
```

From crates/blufio-cost/src/ledger.rs:
```rust
pub enum FeatureType { Message, Compaction, /* Need to add: */ Extraction }
```

From crates/blufio-agent/src/session.rs:
```rust
pub struct SessionActor {
    // ... existing fields
    // Will add: memory_provider, memory_extractor, idle detection
}
```
</interfaces>
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add FeatureType::Extraction and wire memory into startup</name>
  <files>
    crates/blufio-cost/src/ledger.rs,
    crates/blufio/src/main.rs,
    crates/blufio/Cargo.toml,
    crates/blufio-agent/Cargo.toml
  </files>
  <action>
  **Step 1: Add FeatureType::Extraction**

  In `crates/blufio-cost/src/ledger.rs`, add `Extraction` variant to `FeatureType` enum:
  ```rust
  pub enum FeatureType {
      Message,
      Compaction,
      Extraction,  // Memory extraction via Haiku
  }
  ```
  Update the Display/FromStr implementations if they exist. Ensure the `feature_type` TEXT column in cost_ledger accepts "extraction" value.

  **Step 2: Add blufio-memory dependency**

  Add `blufio-memory = { path = "../blufio-memory" }` to:
  - `crates/blufio/Cargo.toml` (binary crate)
  - `crates/blufio-agent/Cargo.toml`

  **Step 3: Wire memory system into startup (main.rs or serve command)**

  In the startup sequence (wherever ContextEngine is created and serve/shell initializes):

  1. Initialize ModelManager with data directory:
     ```rust
     let model_manager = blufio_memory::ModelManager::new(data_dir.clone());
     ```

  2. Download model on first run (only if memory is enabled):
     ```rust
     if config.memory.enabled {
         info!("Ensuring embedding model is available...");
         let model_path = model_manager.ensure_model().await?;
         info!("Embedding model ready at: {}", model_path.display());
     }
     ```

  3. Create OnnxEmbedder:
     ```rust
     let embedder = Arc::new(blufio_memory::OnnxEmbedder::new(&model_path)?);
     ```

  4. Create MemoryStore (reuse existing Database connection):
     ```rust
     let memory_store = Arc::new(blufio_memory::MemoryStore::new(db.conn().clone()));
     ```

  5. Create HybridRetriever:
     ```rust
     let retriever = Arc::new(blufio_memory::HybridRetriever::new(
         memory_store.clone(), embedder.clone(), config.memory.clone(),
     ));
     ```

  6. Create MemoryProvider and register with ContextEngine:
     ```rust
     let memory_provider = Arc::new(blufio_memory::MemoryProvider::new(retriever.clone()));
     context_engine.add_conditional_provider(Box::new(memory_provider.clone()));
     ```

  7. Create MemoryExtractor:
     ```rust
     let extractor = Arc::new(blufio_memory::MemoryExtractor::new(
         memory_store.clone(), embedder.clone(), config.memory.extraction_model.clone(),
     ));
     ```

  8. Pass memory_provider and extractor to SessionActor (via whatever mechanism sessions are created -- likely constructor args or shared state).

  Handle the case where memory is disabled: skip all memory initialization, don't register provider.
  </action>
  <verify>
    <automated>cargo build -p blufio 2>&1 | tail -10</automated>
  </verify>
  <done>
  - FeatureType::Extraction variant exists in cost ledger
  - blufio-memory is a dependency of blufio and blufio-agent
  - Startup initializes ModelManager, OnnxEmbedder, MemoryStore, HybridRetriever, MemoryProvider, MemoryExtractor
  - MemoryProvider is registered with ContextEngine
  - Memory initialization skipped when config.memory.enabled is false
  - `cargo build -p blufio` compiles
  </done>
</task>

<task type="auto" tdd="true">
  <name>Task 2: Integrate memory into session actor with idle extraction and command handling</name>
  <files>
    crates/blufio-agent/src/session.rs,
    crates/blufio-agent/src/context.rs
  </files>
  <behavior>
    - Test 1: SessionActor sets current query on MemoryProvider before calling context_engine.assemble()
    - Test 2: SessionActor clears current query on MemoryProvider after context assembly completes
    - Test 3: "remember this: my dog is Max" triggers extract_explicit and returns confirmation
    - Test 4: "forget that my dog is named Max" triggers search + soft_delete and returns confirmation
    - Test 5: Extraction cost (Haiku call) is recorded in cost ledger with FeatureType::Extraction
    - Test 6: When memory is disabled (config.memory.enabled=false), no memory operations occur
  </behavior>
  <action>
  **Step 1: Add memory fields to SessionActor**

  Add to SessionActor struct:
  ```rust
  /// Memory provider for setting current query before context assembly.
  memory_provider: Option<Arc<MemoryProvider>>,
  /// Memory extractor for end-of-conversation fact extraction.
  memory_extractor: Option<Arc<MemoryExtractor>>,
  /// Timestamp of last message received -- for idle detection.
  last_message_at: Option<chrono::DateTime<chrono::Utc>>,
  /// Idle timeout for triggering extraction (from config).
  idle_timeout: std::time::Duration,
  ```

  Update the constructor to accept these new fields (Option<Arc<...>> so they're None when memory is disabled).

  **Step 2: Wire memory into message processing**

  In the `process_message` (or equivalent) method of SessionActor, BEFORE calling `context_engine.assemble()`:

  ```rust
  // Set current query on memory provider for retrieval
  if let Some(ref mp) = self.memory_provider {
      let query_text = /* extract text from inbound message */;
      mp.set_current_query(&session_id, &query_text).await;
  }
  ```

  AFTER context assembly completes (regardless of success/failure):
  ```rust
  if let Some(ref mp) = self.memory_provider {
      mp.clear_current_query(&session_id).await;
  }
  ```

  Update `last_message_at` on every received message:
  ```rust
  self.last_message_at = Some(chrono::Utc::now());
  ```

  **Step 3: Handle explicit memory commands**

  Before normal message processing, check for memory commands:

  ```rust
  // Check for explicit memory commands
  let text = /* extract message text */;
  let text_lower = text.to_lowercase();

  if let Some(ref extractor) = self.memory_extractor {
      if text_lower.starts_with("remember this:") || text_lower.starts_with("remember that ") {
          let fact = text.trim_start_matches("remember this:")
                        .trim_start_matches("Remember this:")
                        .trim_start_matches("remember that ")
                        .trim_start_matches("Remember that ")
                        .trim();
          match extractor.extract_explicit(fact, &session_id).await {
              Ok(memory) => {
                  // Send confirmation (don't call LLM)
                  return Ok("Got it, I'll remember that.".to_string());
              }
              Err(e) => {
                  tracing::warn!("Failed to save explicit memory: {}", e);
                  // Fall through to normal processing
              }
          }
      }

      if text_lower.starts_with("forget that ") || text_lower.starts_with("forget about ") {
          let search_text = text.trim_start_matches("forget that ")
                               .trim_start_matches("Forget that ")
                               .trim_start_matches("forget about ")
                               .trim_start_matches("Forget about ")
                               .trim();
          // Search for matching memories and soft-delete
          // Use retriever to find relevant memories, then soft_delete each
          // Return confirmation with what was forgotten
      }
  }
  ```

  **Step 4: Implement idle-triggered extraction**

  Add an idle check mechanism. This can be done via:
  - A background tokio task that periodically checks `last_message_at`
  - OR checking on each new message if idle threshold was exceeded since last extraction

  The simpler approach (check on next message):
  ```rust
  // On each new message, check if enough time passed since last message
  // to trigger extraction of the PREVIOUS conversation segment
  if let (Some(ref extractor), Some(last_at)) = (&self.memory_extractor, self.last_message_at) {
      let elapsed = chrono::Utc::now() - last_at;
      if elapsed > chrono::Duration::from_std(self.idle_timeout).unwrap() {
          // Extract from messages since last extraction
          self.trigger_extraction(provider, session_id).await;
      }
  }
  ```

  The `trigger_extraction` method:
  ```rust
  async fn trigger_extraction(&self, provider: &dyn ProviderAdapter, session_id: &str) {
      if let Some(ref extractor) = self.memory_extractor {
          // Get recent messages from storage
          let messages = /* get messages since last extraction */;
          match extractor.extract_from_conversation(provider, session_id, &messages).await {
              Ok(memories) => {
                  info!("Extracted {} memories from session {}", memories.len(), session_id);
                  // Record extraction cost in cost ledger
                  // The extraction uses Haiku, so record the token usage
                  if let Some(usage) = /* get usage from extraction call */ {
                      self.cost_ledger.record(CostRecord {
                          session_id: session_id.to_string(),
                          model: self.memory_config.extraction_model.clone(),
                          feature_type: FeatureType::Extraction,
                          input_tokens: usage.input_tokens,
                          output_tokens: usage.output_tokens,
                          ..Default::default()
                      }).await?;
                  }
              }
              Err(e) => {
                  tracing::warn!("Memory extraction failed for session {}: {}", session_id, e);
                  // Non-fatal -- don't break the session
              }
          }
      }
  }
  ```

  **Step 5: Ensure extraction costs are tracked**

  The MemoryExtractor's `extract_from_conversation` calls the LLM provider (Haiku). The response includes TokenUsage. The SessionActor must capture this and record via CostLedger with FeatureType::Extraction.

  This may require MemoryExtractor to return the TokenUsage alongside the memories:
  ```rust
  pub struct ExtractionResult {
      pub memories: Vec<Memory>,
      pub usage: Option<TokenUsage>,
  }
  ```

  Adjust the extractor return type accordingly and record the cost in session.rs.

  **Step 6: Add graceful degradation**

  Memory operations must NEVER crash the agent:
  - Wrap all memory operations in catch blocks that log warnings
  - If embedder fails, skip memory retrieval but continue normal processing
  - If extraction fails, log and continue
  - If model download fails at startup, log warning and disable memory (set enabled=false at runtime)
  </action>
  <verify>
    <automated>cargo test -p blufio-agent -- --nocapture 2>&1 | tail -20 && cargo test --workspace 2>&1 | tail -10</automated>
  </verify>
  <done>
  - SessionActor sets/clears current query on MemoryProvider around context assembly
  - Explicit "remember this" commands save memory with confidence 0.9
  - Explicit "forget" commands search and soft-delete matching memories
  - Idle detection triggers batch extraction of conversation facts
  - Extraction costs recorded in cost ledger as FeatureType::Extraction
  - Memory disabled gracefully when config.memory.enabled is false
  - All memory failures are non-fatal (logged, not propagated)
  - All workspace tests pass
  </done>
</task>

</tasks>

<verification>
- `cargo build -p blufio` compiles without errors
- `cargo test -p blufio-agent` all tests pass
- `cargo test -p blufio-cost` all tests pass (new FeatureType variant)
- `cargo test --workspace` no regressions
- Memory retrieval injects memories into context assembly via ConditionalProvider
- Extraction costs are tracked in cost ledger
</verification>

<success_criteria>
- MemoryProvider registered with ContextEngine at startup
- SessionActor sets current query before assembly, clears after
- Idle sessions trigger batch memory extraction via Haiku
- Explicit remember/forget commands work
- Extraction costs recorded as FeatureType::Extraction
- Memory failures are non-fatal -- agent continues without memory if anything fails
- All workspace tests pass
</success_criteria>

<output>
After completion, create `.planning/phases/05-memory-embeddings/05-03-SUMMARY.md`
</output>
