---
phase: 05-memory-embeddings
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - Cargo.toml
  - crates/blufio-memory/Cargo.toml
  - crates/blufio-memory/src/lib.rs
  - crates/blufio-memory/src/types.rs
  - crates/blufio-memory/src/embedder.rs
  - crates/blufio-memory/src/model_manager.rs
  - crates/blufio-memory/src/store.rs
  - crates/blufio-core/src/types.rs
  - crates/blufio-storage/migrations/V3__memory_tables.sql
  - crates/blufio-storage/src/migrations.rs
  - crates/blufio-config/src/model.rs
autonomous: true
requirements:
  - MEM-02
  - MEM-05

must_haves:
  truths:
    - OnnxEmbedder loads an ONNX model from disk and produces 384-dim f32 vectors
    - EmbeddingInput/EmbeddingOutput types in blufio-core have real fields (not placeholder)
    - OnnxEmbedder implements EmbeddingAdapter trait
    - MemoryStore persists memories with embeddings as BLOB in SQLite
    - SQLite FTS5 virtual table is created and kept in sync via triggers
    - Model manager downloads model from HuggingFace on first run if not cached
    - V3 migration creates memories table, memories_fts virtual table, and sync triggers
  artifacts:
    - crates/blufio-memory/src/lib.rs
    - crates/blufio-memory/src/embedder.rs
    - crates/blufio-memory/src/store.rs
    - crates/blufio-memory/src/model_manager.rs
    - crates/blufio-memory/src/types.rs
    - crates/blufio-storage/migrations/V3__memory_tables.sql
  key_links:
    - OnnxEmbedder implements EmbeddingAdapter from blufio-core
    - MemoryStore uses Database from blufio-storage for SQLite access
    - V3 migration runs automatically via refinery on DB open
---

<objective>
Create the blufio-memory crate with ONNX embedding inference, memory type definitions, SQLite memory store with FTS5, and model download manager.

Purpose: Establish the foundation for the memory system -- types, embedding engine, persistence layer, and model management. This is the data layer that Plan 02 builds retrieval and extraction on top of.

Output: New blufio-memory crate with OnnxEmbedder, MemoryStore, ModelManager, and supporting types. Updated blufio-core EmbeddingInput/EmbeddingOutput types. V3 SQLite migration for memory tables.
</objective>

<execution_context>
@/Users/suman/.claude/get-shit-done/workflows/execute-plan.md
@/Users/suman/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/STATE.md
@.planning/ROADMAP.md
@.planning/phases/05-memory-embeddings/05-CONTEXT.md
@.planning/phases/05-memory-embeddings/05-RESEARCH.md

@crates/blufio-core/src/types.rs
@crates/blufio-core/src/traits/embedding.rs
@crates/blufio-core/src/error.rs
@crates/blufio-storage/src/lib.rs
@crates/blufio-storage/src/database.rs
@crates/blufio-storage/src/migrations.rs
@crates/blufio-config/src/model.rs
@Cargo.toml

<interfaces>
<!-- Key types and contracts from existing crates -->

From crates/blufio-core/src/traits/embedding.rs:
```rust
#[async_trait]
pub trait EmbeddingAdapter: PluginAdapter {
    async fn embed(&self, input: EmbeddingInput) -> Result<EmbeddingOutput, BlufioError>;
}
```

From crates/blufio-core/src/traits/adapter.rs:
```rust
#[async_trait]
pub trait PluginAdapter: Send + Sync {
    fn name(&self) -> &str;
    fn adapter_type(&self) -> AdapterType;
    fn version(&self) -> &str;
    async fn health_check(&self) -> Result<HealthStatus, BlufioError>;
}
```

From crates/blufio-core/src/types.rs (placeholders to replace):
```rust
pub struct EmbeddingInput { pub _placeholder: () }
pub struct EmbeddingOutput { pub _placeholder: () }
```

From crates/blufio-storage/src/database.rs:
```rust
pub struct Database { /* wraps tokio_rusqlite::Connection */ }
impl Database {
    pub async fn open(path: impl AsRef<Path>) -> Result<Self, BlufioError>;
    pub fn conn(&self) -> &tokio_rusqlite::Connection;
}
```
</interfaces>
</context>

<tasks>

<task type="auto" tdd="true">
  <name>Task 1: Create blufio-memory crate with types, embedder, and model manager</name>
  <files>
    Cargo.toml,
    crates/blufio-memory/Cargo.toml,
    crates/blufio-memory/src/lib.rs,
    crates/blufio-memory/src/types.rs,
    crates/blufio-memory/src/embedder.rs,
    crates/blufio-memory/src/model_manager.rs,
    crates/blufio-core/src/types.rs
  </files>
  <behavior>
    - Test 1: EmbeddingInput can be created with text field; EmbeddingOutput contains Vec of f32 vectors
    - Test 2: Memory struct has id, content, embedding, source, confidence, status fields
    - Test 3: MemorySource enum has Explicit and Extracted variants
    - Test 4: MemoryStatus enum has Active, Superseded, Forgotten variants
    - Test 5: vec_to_blob converts f32 slice to bytes; blob_to_vec converts back losslessly
    - Test 6: cosine_similarity of identical normalized vectors returns ~1.0
    - Test 7: cosine_similarity of orthogonal vectors returns ~0.0
    - Test 8: ModelManager::model_path returns expected path under data directory
    - Test 9: OnnxEmbedder implements EmbeddingAdapter trait (compile-time check)
  </behavior>
  <action>
  **Step 1: Add workspace dependencies**

  In root `Cargo.toml`, add to `[workspace.dependencies]`:
  ```toml
  ort = { version = "=2.0.0-rc.11", default-features = false }
  tokenizers = { version = "0.21", default-features = false, features = ["onig"] }
  ndarray = "0.16"
  serde_json = "1"
  ```
  Note: serde_json may already be used -- check first. Keep existing entries.

  **Step 2: Create crates/blufio-memory/Cargo.toml**
  ```toml
  [package]
  name = "blufio-memory"
  version.workspace = true
  edition.workspace = true
  rust-version.workspace = true
  license.workspace = true

  [dependencies]
  blufio-core = { path = "../blufio-core" }
  blufio-storage = { path = "../blufio-storage" }
  blufio-config = { path = "../blufio-config" }
  ort.workspace = true
  tokenizers.workspace = true
  ndarray.workspace = true
  async-trait.workspace = true
  tokio = { workspace = true, features = ["fs", "sync"] }
  tokio-rusqlite.workspace = true
  reqwest = { workspace = true }
  serde.workspace = true
  serde_json.workspace = true
  uuid.workspace = true
  chrono.workspace = true
  tracing.workspace = true

  [dev-dependencies]
  tokio = { workspace = true, features = ["rt-multi-thread", "macros"] }
  tempfile = "3"
  ```

  **Step 3: Update blufio-core EmbeddingInput/EmbeddingOutput**

  In `crates/blufio-core/src/types.rs`, replace the placeholder structs:
  ```rust
  /// Input for an embedding adapter.
  #[derive(Debug, Clone)]
  pub struct EmbeddingInput {
      /// Text strings to embed.
      pub texts: Vec<String>,
  }

  /// Output from an embedding adapter.
  #[derive(Debug, Clone)]
  pub struct EmbeddingOutput {
      /// One embedding vector per input text.
      pub embeddings: Vec<Vec<f32>>,
      /// Dimensionality of each embedding vector.
      pub dimensions: usize,
  }
  ```

  **Step 4: Create types.rs**

  Define memory domain types:
  ```rust
  use serde::{Deserialize, Serialize};

  #[derive(Debug, Clone, Serialize, Deserialize)]
  pub struct Memory {
      pub id: String,
      pub content: String,
      pub embedding: Vec<f32>,
      pub source: MemorySource,
      pub confidence: f64,
      pub status: MemoryStatus,
      pub superseded_by: Option<String>,
      pub session_id: Option<String>,
      pub created_at: String,
      pub updated_at: String,
  }

  #[derive(Debug, Clone, Copy, PartialEq, Eq, Serialize, Deserialize)]
  pub enum MemorySource {
      Explicit,    // User said "remember this"
      Extracted,   // LLM-extracted from conversation
  }

  #[derive(Debug, Clone, Copy, PartialEq, Eq, Serialize, Deserialize)]
  pub enum MemoryStatus {
      Active,
      Superseded,
      Forgotten,
  }
  ```

  Add helper functions:
  ```rust
  /// Convert f32 vector to bytes for SQLite BLOB storage.
  pub fn vec_to_blob(vec: &[f32]) -> Vec<u8> {
      vec.iter().flat_map(|f| f.to_le_bytes()).collect()
  }

  /// Convert SQLite BLOB back to f32 vector.
  pub fn blob_to_vec(blob: &[u8]) -> Vec<f32> {
      blob.chunks_exact(4)
          .map(|chunk| f32::from_le_bytes(chunk.try_into().unwrap()))
          .collect()
  }

  /// Compute cosine similarity between two L2-normalized vectors.
  pub fn cosine_similarity(a: &[f32], b: &[f32]) -> f32 {
      assert_eq!(a.len(), b.len(), "vectors must have same length");
      a.iter().zip(b.iter()).map(|(x, y)| x * y).sum()
  }
  ```

  **Step 5: Create model_manager.rs**

  ModelManager handles first-run download and model path management:
  - `ModelManager::new(data_dir: PathBuf)` stores the data dir
  - `model_dir()` returns `{data_dir}/models/all-MiniLM-L6-v2/`
  - `model_path()` returns `{model_dir}/model.onnx`
  - `tokenizer_path()` returns `{model_dir}/tokenizer.json`
  - `is_model_available()` checks if both files exist
  - `async ensure_model()` downloads from HuggingFace if not present:
    - model.onnx from: `https://huggingface.co/onnx-community/all-MiniLM-L6-v2-ONNX/resolve/main/onnx/model_quantized.onnx`
    - tokenizer.json from: `https://huggingface.co/sentence-transformers/all-MiniLM-L6-v2/resolve/main/tokenizer.json`
  - Use `tokio::sync::OnceCell` or a file lock to prevent concurrent downloads
  - Log progress via tracing: `info!("Downloading embedding model ({} bytes)...", size)`

  **Step 6: Create embedder.rs**

  OnnxEmbedder wraps ort Session + tokenizers Tokenizer:
  - `OnnxEmbedder::new(model_path: &Path) -> Result<Self, BlufioError>`:
    - Load tokenizer from `{model_dir}/tokenizer.json`
    - Create ort Session with `GraphOptimizationLevel::Level3`, `with_intra_threads(1)` (CPU-only VPS)
    - Load model from `{model_dir}/model.onnx`
  - Implement `EmbeddingAdapter` trait:
    - `embed(input: EmbeddingInput) -> Result<EmbeddingOutput, BlufioError>`:
      - For each text in input.texts:
        - Tokenize with tokenizer.encode(text, true)
        - Create input_ids and attention_mask tensors (i64 type, shape [1, seq_len])
        - Create token_type_ids tensor (zeros, same shape)
        - Run session.run with named inputs: "input_ids", "attention_mask", "token_type_ids"
        - Extract output tensor, apply attention-masked mean pooling
        - L2-normalize the resulting vector
      - Return EmbeddingOutput with all vectors, dimensions=384
  - Implement `PluginAdapter` trait: name="onnx-embedder", adapter_type=Embedding, version="0.1.0"
  - CRITICAL: Apply attention mask before mean pooling to avoid including padding tokens

  **Step 7: Create lib.rs**

  Re-export public API:
  ```rust
  pub mod embedder;
  pub mod model_manager;
  pub mod store;
  pub mod types;

  pub use embedder::OnnxEmbedder;
  pub use model_manager::ModelManager;
  pub use store::MemoryStore;
  pub use types::*;
  ```
  </action>
  <verify>
    <automated>cargo test -p blufio-memory --lib -- --nocapture 2>&1 | tail -20</automated>
  </verify>
  <done>
  - blufio-memory crate compiles with all dependencies
  - EmbeddingInput/EmbeddingOutput in blufio-core have real text/vector fields
  - Memory, MemorySource, MemoryStatus types defined
  - vec_to_blob/blob_to_vec roundtrip correctly
  - cosine_similarity computes correct dot product
  - OnnxEmbedder struct compiles with Session and Tokenizer fields
  - ModelManager provides path management and download URLs
  - All existing tests in workspace still pass: `cargo test --workspace`
  </done>
</task>

<task type="auto" tdd="true">
  <name>Task 2: Create memory SQLite store with V3 migration and FTS5</name>
  <files>
    crates/blufio-storage/migrations/V3__memory_tables.sql,
    crates/blufio-memory/src/store.rs,
    crates/blufio-config/src/model.rs
  </files>
  <behavior>
    - Test 1: V3 migration creates memories table with all columns (id, content, embedding, source, confidence, status, superseded_by, session_id, created_at, updated_at)
    - Test 2: V3 migration creates memories_fts FTS5 virtual table
    - Test 3: MemoryStore::save stores a Memory and can retrieve it by ID
    - Test 4: MemoryStore::save stores embedding as BLOB, retrievable as Vec of f32
    - Test 5: MemoryStore::get_active returns only memories with status='active'
    - Test 6: MemoryStore::soft_delete sets status to 'forgotten' (does NOT actually delete)
    - Test 7: MemoryStore::supersede sets status='superseded' and superseded_by on old memory
    - Test 8: FTS5 content sync trigger works -- inserted memory is searchable via FTS5 MATCH
    - Test 9: MemoryConfig added to BlufioConfig with similarity_threshold and model_path defaults
  </behavior>
  <action>
  **Step 1: Create V3 migration**

  Create `crates/blufio-storage/migrations/V3__memory_tables.sql`:
  ```sql
  -- Long-term memory storage with vector embeddings.
  -- Each row stores a discrete fact extracted from conversations.

  CREATE TABLE IF NOT EXISTS memories (
      id TEXT PRIMARY KEY NOT NULL,
      content TEXT NOT NULL,
      embedding BLOB NOT NULL,
      source TEXT NOT NULL,
      confidence REAL NOT NULL DEFAULT 0.5,
      status TEXT NOT NULL DEFAULT 'active',
      superseded_by TEXT,
      session_id TEXT,
      created_at TEXT NOT NULL DEFAULT (strftime('%Y-%m-%dT%H:%M:%fZ', 'now')),
      updated_at TEXT NOT NULL DEFAULT (strftime('%Y-%m-%dT%H:%M:%fZ', 'now'))
  );

  -- FTS5 virtual table for BM25 keyword search
  CREATE VIRTUAL TABLE IF NOT EXISTS memories_fts USING fts5(
      content,
      content='memories',
      content_rowid='rowid'
  );

  -- Triggers to keep FTS5 in sync with memories table
  CREATE TRIGGER IF NOT EXISTS memories_ai AFTER INSERT ON memories BEGIN
      INSERT INTO memories_fts(rowid, content) VALUES (new.rowid, new.content);
  END;

  CREATE TRIGGER IF NOT EXISTS memories_ad AFTER DELETE ON memories BEGIN
      INSERT INTO memories_fts(memories_fts, rowid, content)
          VALUES('delete', old.rowid, old.content);
  END;

  CREATE TRIGGER IF NOT EXISTS memories_au AFTER UPDATE ON memories BEGIN
      INSERT INTO memories_fts(memories_fts, rowid, content)
          VALUES('delete', old.rowid, old.content);
      INSERT INTO memories_fts(rowid, content) VALUES (new.rowid, new.content);
  END;

  CREATE INDEX IF NOT EXISTS idx_memories_status ON memories(status);
  CREATE INDEX IF NOT EXISTS idx_memories_created ON memories(created_at);
  ```

  **Step 2: Create MemoryStore in store.rs**

  MemoryStore wraps `tokio_rusqlite::Connection` (obtained from Database):

  - `MemoryStore::new(conn: tokio_rusqlite::Connection) -> Self`
  - `async save(&self, memory: &Memory) -> Result<(), BlufioError>`:
    - INSERT into memories table with embedding as vec_to_blob()
    - source as string ("explicit"/"extracted"), status as string ("active"/"superseded"/"forgotten")
  - `async get_by_id(&self, id: &str) -> Result<Option<Memory>, BlufioError>`:
    - SELECT from memories, blob_to_vec for embedding
  - `async get_active(&self) -> Result<Vec<Memory>, BlufioError>`:
    - SELECT WHERE status = 'active' ORDER BY created_at DESC
  - `async get_active_embeddings(&self) -> Result<Vec<(String, Vec<f32>)>, BlufioError>`:
    - SELECT id, embedding WHERE status = 'active' -- lightweight for vector search
  - `async search_bm25(&self, query: &str, limit: usize) -> Result<Vec<(String, f64)>, BlufioError>`:
    - SELECT m.id, bm25(memories_fts) FROM memories_fts JOIN memories m ON m.rowid = memories_fts.rowid WHERE memories_fts MATCH ? AND m.status = 'active' ORDER BY bm25(memories_fts) LIMIT ?
    - Returns (memory_id, bm25_score) pairs
  - `async soft_delete(&self, id: &str) -> Result<(), BlufioError>`:
    - UPDATE memories SET status='forgotten', updated_at=now WHERE id=?
  - `async supersede(&self, old_id: &str, new_id: &str) -> Result<(), BlufioError>`:
    - UPDATE memories SET status='superseded', superseded_by=?, updated_at=now WHERE id=?
  - `async get_memories_by_ids(&self, ids: &[String]) -> Result<Vec<Memory>, BlufioError>`:
    - SELECT from memories WHERE id IN (?) -- for batch retrieval after hybrid search

  Use `conn.call(move |conn| { ... })` pattern from tokio-rusqlite (same pattern as blufio-storage queries.rs).

  **Step 3: Add MemoryConfig to blufio-config**

  In `crates/blufio-config/src/model.rs`:
  - Add `MemoryConfig` struct with `#[serde(deny_unknown_fields)]`:
    ```rust
    pub struct MemoryConfig {
        pub enabled: bool,                    // default: true
        pub similarity_threshold: f64,        // default: 0.35
        pub model_name: String,               // default: "all-MiniLM-L6-v2"
        pub extraction_model: String,         // default: "claude-haiku-4-5-20250901"
        pub idle_timeout_secs: u64,           // default: 300 (5 minutes)
        pub max_retrieval_results: usize,     // default: 50 (pre-RRF candidate limit)
    }
    ```
  - Add `#[serde(default)] pub memory: MemoryConfig` to `BlufioConfig`
  </action>
  <verify>
    <automated>cargo test -p blufio-memory --lib -- --nocapture 2>&1 | tail -20 && cargo test -p blufio-storage -- --nocapture 2>&1 | tail -10</automated>
  </verify>
  <done>
  - V3 migration file exists and creates memories + memories_fts tables with sync triggers
  - MemoryStore CRUD operations work: save, get_by_id, get_active, search_bm25, soft_delete, supersede
  - FTS5 sync verified: saving a memory makes it searchable via BM25
  - Embeddings stored as BLOB and retrieved as Vec of f32 with no data loss
  - MemoryConfig added to BlufioConfig with sensible defaults
  - All workspace tests pass: `cargo test --workspace`
  </done>
</task>

</tasks>

<verification>
- `cargo build -p blufio-memory` compiles without errors
- `cargo test -p blufio-memory` all tests pass
- `cargo test -p blufio-storage` all tests pass (V3 migration)
- `cargo test -p blufio-config` all tests pass (MemoryConfig)
- `cargo test -p blufio-core` all tests pass (updated EmbeddingInput/Output)
- `cargo test --workspace` no regressions
</verification>

<success_criteria>
- blufio-memory crate exists with OnnxEmbedder, MemoryStore, ModelManager, types
- EmbeddingInput/EmbeddingOutput in blufio-core have real fields (texts, embeddings, dimensions)
- OnnxEmbedder implements EmbeddingAdapter trait
- V3 migration creates memories table + FTS5 virtual table with sync triggers
- MemoryStore provides CRUD + BM25 search against SQLite
- MemoryConfig added to BlufioConfig
- All workspace tests pass
</success_criteria>

<output>
After completion, create `.planning/phases/05-memory-embeddings/05-01-SUMMARY.md`
</output>
