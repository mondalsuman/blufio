---
phase: 10-multi-agent-final-integration
plan: 03
type: execute
wave: 2
depends_on: [10-01, 10-02]
files_modified:
  - crates/blufio-agent/src/delegation.rs
  - crates/blufio-agent/src/lib.rs
  - crates/blufio-agent/Cargo.toml
  - crates/blufio/src/serve.rs
  - crates/blufio/Cargo.toml
  - crates/blufio/tests/e2e.rs
autonomous: true
requirements: [SEC-07, INFRA-06]

must_haves:
  truths:
    - "DelegationTool registered in ToolRegistry delegates tasks to configured specialist agents"
    - "Specialist SessionActor runs to completion with its own system prompt and returns result"
    - "All delegation messages are Ed25519-signed and verified before processing"
    - "Delegation has a configurable timeout and returns an error if specialist takes too long"
    - "E2E tests pass covering: message pipeline, conversation persistence, tool execution, delegation, cost tracking, budget enforcement, Ed25519 signing"
    - "Specialist sessions are ephemeral -- created per delegation and dropped after"
  artifacts:
    - path: "crates/blufio-agent/src/delegation.rs"
      provides: "DelegationRouter and DelegationTool for multi-agent routing"
      contains: "struct DelegationRouter"
    - path: "crates/blufio/tests/e2e.rs"
      provides: "End-to-end integration tests for the complete Blufio pipeline"
      contains: "async fn test_"
  key_links:
    - from: "crates/blufio-agent/src/delegation.rs"
      to: "crates/blufio-auth-keypair/src/message.rs"
      via: "DelegationRouter creates SignedAgentMessages for all delegation communication"
      pattern: "SignedAgentMessage::new"
    - from: "crates/blufio-agent/src/delegation.rs"
      to: "crates/blufio-agent/src/session.rs"
      via: "DelegationRouter creates ephemeral specialist SessionActors"
      pattern: "SessionActor::new"
    - from: "crates/blufio/src/serve.rs"
      to: "crates/blufio-agent/src/delegation.rs"
      via: "serve.rs initializes DelegationRouter and registers DelegationTool"
      pattern: "DelegationRouter::new|DelegationTool"
    - from: "crates/blufio/tests/e2e.rs"
      to: "crates/blufio-test-utils/src/harness.rs"
      via: "E2E tests use TestHarness for test environment setup"
      pattern: "TestHarness::builder"
---

<objective>
Implement multi-agent delegation (DelegationRouter + DelegationTool), wire into serve.rs, and create comprehensive E2E integration tests validating the complete Blufio pipeline.

Purpose: Delivers the core multi-agent capability (INFRA-06) with Ed25519 signed messages (SEC-07) and validates the entire system works end-to-end. This is the final integration plan that completes Phase 10 and the v1 milestone.

Output: DelegationRouter and DelegationTool in blufio-agent, serve.rs wiring, E2E integration test suite.
</objective>

<execution_context>
@/Users/suman/.claude/get-shit-done/workflows/execute-plan.md
@/Users/suman/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/STATE.md
@.planning/ROADMAP.md
@.planning/phases/10-multi-agent-final-integration/10-01-SUMMARY.md
@.planning/phases/10-multi-agent-final-integration/10-02-SUMMARY.md

<interfaces>
<!-- Types created by Plan 10-01 -->

From crates/blufio-auth-keypair (after Plan 10-01):
```rust
pub struct DeviceKeypair {
    pub fn generate() -> Self;
    pub fn sign(&self, message: &[u8]) -> Signature;
    pub fn verify_strict(&self, message: &[u8], signature: &Signature) -> Result<(), BlufioError>;
}

pub struct AgentMessage {
    pub fn new_request(sender: &str, recipient: &str, task: &str, context: &str) -> Self;
    pub fn new_response(request: &AgentMessage, sender: &str, content: &str) -> Self;
    pub fn canonical_bytes(&self) -> Vec<u8>;
}

pub struct SignedAgentMessage {
    pub fn new(message: AgentMessage, keypair: &DeviceKeypair) -> Self;
    pub fn verify(&self, sender_keypair: &DeviceKeypair) -> Result<(), BlufioError>;
}
```

From crates/blufio-config (after Plan 10-01):
```rust
pub struct AgentSpecConfig {
    pub name: String,
    pub system_prompt: String,
    pub model: String,
    pub allowed_skills: Vec<String>,
}

pub struct DelegationConfig {
    pub enabled: bool,
    pub timeout_secs: u64,
}

pub struct BlufioConfig {
    // ... existing fields ...
    pub agents: Vec<AgentSpecConfig>,
    pub delegation: DelegationConfig,
}
```

<!-- Types created by Plan 10-02 -->

From crates/blufio-test-utils (after Plan 10-02):
```rust
pub struct MockProvider { /* queued responses */ }
pub struct MockChannel { /* message injection + capture */ }
pub struct TestHarness {
    pub fn builder() -> TestHarnessBuilder;
    pub async fn send_message(&self, text: &str) -> Result<String, BlufioError>;
    pub fn provider() -> &Arc<MockProvider>;
    pub fn channel() -> &Arc<MockChannel>;
    pub fn storage() -> &Arc<dyn StorageAdapter + Send + Sync>;
    pub fn cost_ledger() -> &Arc<CostLedger>;
}
```

From crates/blufio-agent/src/session.rs (existing):
```rust
pub struct SessionActor {
    pub fn new(session_id, storage, provider, context_engine, budget_tracker, cost_ledger, memory_provider, memory_extractor, channel, router, default_model, default_max_tokens, routing_enabled, idle_timeout_secs, tool_registry) -> Self;
    pub async fn handle_message(&mut self, inbound: InboundMessage) -> Result<Pin<Box<dyn Stream<...>>>, BlufioError>;
    pub async fn persist_response(&mut self, text: &str, usage: Option<TokenUsage>) -> Result<(), BlufioError>;
    pub async fn execute_tools(&mut self, tool_uses: &[ToolUseData]) -> Result<Vec<(String, ToolOutput)>, BlufioError>;
}
```

From crates/blufio-skill/src/tool.rs (existing):
```rust
#[async_trait]
pub trait Tool: Send + Sync {
    fn name(&self) -> &str;
    fn description(&self) -> &str;
    fn parameters_schema(&self) -> serde_json::Value;
    async fn invoke(&self, input: serde_json::Value) -> Result<ToolOutput, BlufioError>;
}
pub struct ToolRegistry {
    pub fn register(&mut self, tool: Arc<dyn Tool>);
}
```
</interfaces>
</context>

<tasks>

<task type="auto" tdd="true">
  <name>Task 1: Implement DelegationRouter and DelegationTool</name>
  <files>crates/blufio-agent/src/delegation.rs, crates/blufio-agent/src/lib.rs, crates/blufio-agent/Cargo.toml</files>
  <behavior>
    - Test: DelegationRouter::new() creates router with agent configs and generates per-agent keypairs
    - Test: DelegationRouter::delegate() creates signed request, spawns ephemeral specialist, returns signed response
    - Test: DelegationRouter::delegate() returns error for unknown agent name
    - Test: DelegationRouter::delegate() returns timeout error when specialist takes too long (use very short timeout + mock that delays)
    - Test: Delegation request and response messages are both Ed25519 signed and verified
    - Test: DelegationTool implements Tool trait with correct name, description, and schema
    - Test: DelegationTool::invoke() with valid agent/task returns specialist response as ToolOutput
    - Test: Specialist sessions are NOT stored in the agent's session map (ephemeral)
    - Test: Single-level depth enforcement -- specialist tool_registry does NOT contain delegate_to_specialist
  </behavior>
  <action>
Add `blufio-auth-keypair` dependency to blufio-agent/Cargo.toml.

Create `crates/blufio-agent/src/delegation.rs` with:

**DelegationRouter:**
```rust
pub struct DelegationRouter {
    agents: HashMap<String, AgentSpec>,
    primary_keypair: DeviceKeypair,
    agent_keypairs: HashMap<String, DeviceKeypair>,
    provider: Arc<dyn ProviderAdapter + Send + Sync>,
    storage: Arc<dyn StorageAdapter + Send + Sync>,
    context_engine: Arc<ContextEngine>,
    cost_ledger: Arc<CostLedger>,
    budget_tracker: Arc<tokio::sync::Mutex<BudgetTracker>>,
    router: Arc<ModelRouter>,
    timeout: Duration,
}

struct AgentSpec {
    config: AgentSpecConfig,
    keypair: DeviceKeypair,
}
```

Constructor: `DelegationRouter::new(agents_config, provider, storage, context_engine, cost_ledger, budget_tracker, router, timeout_secs)`
- Generates a primary_keypair for the main agent
- Generates one DeviceKeypair per specialist agent
- Stores agent configs + keypairs in the HashMap

`DelegationRouter::delegate(agent_name, task, context) -> Result<String, BlufioError>`:
1. Look up agent in registry, error if not found
2. Create `AgentMessage::new_request("primary", agent_name, task, context)`
3. Sign it: `SignedAgentMessage::new(request, &self.primary_keypair)`
4. Verify the signed request (paranoid self-check): `signed_req.verify(&self.primary_keypair)?`
5. Create ephemeral specialist SessionActor:
   - Generate unique session_id (uuid)
   - Use agent's configured model as default_model
   - Create a ToolRegistry filtered to agent's allowed_skills (do NOT include delegate_to_specialist -- single-level depth enforcement)
   - Set routing_enabled = false (specialist uses its configured model)
6. Build an InboundMessage with the task + context as content, agent's system_prompt as metadata
7. Use `tokio::time::timeout(self.timeout, ...)` to wrap the specialist call
8. Call specialist's handle_message -> consume stream -> persist_response
9. Create `AgentMessage::new_response(&request, agent_name, &response_text)`
10. Sign response: `SignedAgentMessage::new(response, &agent_keypair)`
11. Verify response: `signed_resp.verify(&agent_keypair)?`
12. Return `response_text` (the specialist's text response)
13. Drop the specialist SessionActor (ephemeral -- goes out of scope)

**DelegationTool:**
```rust
pub struct DelegationTool {
    router: Arc<DelegationRouter>,
}

#[async_trait]
impl Tool for DelegationTool {
    fn name(&self) -> &str { "delegate_to_specialist" }

    fn description(&self) -> &str {
        "Delegate a task to a specialist agent. The specialist will process the task independently and return a result."
    }

    fn parameters_schema(&self) -> serde_json::Value {
        serde_json::json!({
            "type": "object",
            "properties": {
                "agent": {
                    "type": "string",
                    "description": "Name of the specialist agent to delegate to"
                },
                "task": {
                    "type": "string",
                    "description": "Description of the task for the specialist"
                },
                "context": {
                    "type": "string",
                    "description": "Relevant context for the specialist to use"
                }
            },
            "required": ["agent", "task"]
        })
    }

    async fn invoke(&self, input: serde_json::Value) -> Result<ToolOutput, BlufioError> {
        let agent = input["agent"].as_str()
            .ok_or_else(|| BlufioError::Internal("delegate: missing 'agent' field".into()))?;
        let task = input["task"].as_str()
            .ok_or_else(|| BlufioError::Internal("delegate: missing 'task' field".into()))?;
        let context = input["context"].as_str().unwrap_or("");

        match self.router.delegate(agent, task, context).await {
            Ok(result) => Ok(ToolOutput { content: result, is_error: false }),
            Err(e) => Ok(ToolOutput { content: format!("Delegation failed: {e}"), is_error: true }),
        }
    }
}
```

Add `pub mod delegation;` to lib.rs. Re-export `DelegationRouter` and `DelegationTool`.

For the specialist's ContextEngine: create a minimal ContextEngine with the specialist's system_prompt as the agent config's system_prompt. The specialist does NOT share the primary's context engine -- it gets a fresh one per the user decision "fresh context per delegation."

Write unit tests using MockProvider from blufio-test-utils (add as dev-dependency). The timeout test should use a MockProvider that delays response via `tokio::time::sleep` longer than the configured timeout.
  </action>
  <verify>
    <automated>cargo test -p blufio-agent -- delegation --nocapture</automated>
  </verify>
  <done>DelegationRouter creates and manages specialist agents with per-agent keypairs, DelegationTool implements Tool trait for LLM tool-use integration, all delegation messages are Ed25519 signed and verified, timeout and error handling work, specialist sessions are ephemeral, single-level depth enforced, all tests pass.</done>
</task>

<task type="auto">
  <name>Task 2: Wire delegation into serve.rs and create E2E integration tests</name>
  <files>crates/blufio/src/serve.rs, crates/blufio/Cargo.toml, crates/blufio/tests/e2e.rs</files>
  <action>
**Part A: Wire delegation into serve.rs**

In `run_serve()`, after the tool_registry is created and before it's wrapped in Arc:

1. Check if `config.delegation.enabled` and `!config.agents.is_empty()`
2. If enabled, create a `DelegationRouter`:
```rust
if config.delegation.enabled && !config.agents.is_empty() {
    let delegation_router = Arc::new(DelegationRouter::new(
        &config.agents,
        provider.clone(),
        storage.clone(),
        context_engine.clone(), // Will be cloned per-specialist inside
        cost_ledger.clone(),
        budget_tracker.clone(),
        router.clone(),
        config.delegation.timeout_secs,
    ));
    let delegation_tool = DelegationTool::new(delegation_router);
    tool_registry.register(Arc::new(delegation_tool));
    info!(
        agents = config.agents.len(),
        timeout_secs = config.delegation.timeout_secs,
        "multi-agent delegation enabled"
    );
} else {
    debug!("multi-agent delegation disabled");
}
```

Add `blufio-agent` import for `DelegationRouter` and `DelegationTool` (it's likely already imported but may need the new types).

**Part B: Create E2E integration tests**

Add to blufio/Cargo.toml:
```toml
[dev-dependencies]
blufio-test-utils = { path = "../blufio-test-utils" }
tokio = { workspace = true, features = ["test-util", "macros", "rt-multi-thread"] }
tempfile = "3"
```

Create `crates/blufio/tests/e2e.rs` with `#[tokio::test]` tests:

**Test 1: Message-to-response pipeline**
- Create TestHarness with a mock response "Hello from Blufio!"
- Send "Hi there"
- Assert response contains "Hello from Blufio!"
- Assert user message persisted in storage
- Assert assistant message persisted in storage

**Test 2: Conversation persistence across restart**
- Create TestHarness, send a message, get response
- Read the temp DB path from harness
- Create a NEW TestHarness pointing to the SAME DB path
- Verify the session still exists with messages from first run
- Send another message on the same session
- Verify all messages (both old and new) are retrievable

**Test 3: Cost tracking and budget enforcement**
- Create TestHarness with $0.001 daily budget (very small)
- Send first message -- should succeed, cost recorded
- Verify cost record in ledger (session_id, model, feature_type)
- Send messages until budget is exceeded
- Verify BudgetExhausted error or message

**Test 4: Ed25519 signing/verification**
- Create two DeviceKeypairs (primary + specialist)
- Create AgentMessage request, sign with primary keypair
- Verify with primary keypair -- succeeds
- Tamper with message content, re-verify -- fails
- Verify with wrong keypair -- fails
- Create response, sign with specialist keypair, verify -- succeeds

**Test 5: Multi-agent delegation** (if delegation wiring is testable)
- Create TestHarness with delegation enabled and a specialist config
- MockProvider queued with: (1) primary response requesting delegation tool call, (2) specialist response, (3) primary follow-up incorporating specialist result
- This test is more complex -- if the tool_use flow through SessionActor is too complex to mock properly, this can be a simpler unit test:
  - Create DelegationRouter with MockProvider
  - Call delegate() directly
  - Verify signed messages and response content

**Test 6: Tool execution loop**
- This validates that SessionActor correctly handles tool_use/tool_result cycles
- Create TestHarness with a mock tool registered
- Queue MockProvider responses: first with tool_use, then with final text
- Verify the tool was invoked and final response incorporates tool result

Each test creates its own TestHarness (isolated temp DB, fresh mocks). Tests MUST be independent and order-insensitive.

NOTE: Some tests may need to work at a lower level than TestHarness::send_message() if the mock stream needs to include tool_use blocks. In that case, construct the stream manually and drive SessionActor directly. Use the mock_provider to create appropriate ProviderStreamChunk sequences.
  </action>
  <verify>
    <automated>cargo test -p blufio --test e2e -- --nocapture</automated>
  </verify>
  <done>serve.rs initializes DelegationRouter and registers DelegationTool when config.delegation.enabled, E2E tests pass covering: message pipeline, conversation persistence, cost tracking, budget enforcement, Ed25519 signing, multi-agent delegation (or delegation router unit test), workspace compiles clean.</done>
</task>

</tasks>

<verification>
- `cargo test -p blufio-agent -- delegation` -- delegation unit tests pass
- `cargo test -p blufio --test e2e` -- E2E integration tests pass
- `cargo build --workspace` -- full workspace compiles
- `cargo clippy --workspace` -- no warnings
- `cargo test --workspace` -- all workspace tests pass (regression check)
</verification>

<success_criteria>
- DelegationRouter manages specialist agent lifecycle with per-agent Ed25519 keypairs
- DelegationTool registered in ToolRegistry enables LLM-driven delegation decisions
- All inter-agent messages are Ed25519 signed and strictly verified (SEC-07)
- Single-level depth enforced -- specialists cannot delegate further (INFRA-06)
- serve.rs wires delegation when config.delegation.enabled
- E2E tests validate: message pipeline, persistence, cost tracking, budget enforcement, Ed25519 signing, delegation
- All tests pass, workspace compiles clean
</success_criteria>

<output>
After completion, create `.planning/phases/10-multi-agent-final-integration/10-03-SUMMARY.md`
</output>
